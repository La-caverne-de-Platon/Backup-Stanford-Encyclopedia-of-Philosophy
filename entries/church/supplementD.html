<!DOCTYPE html>
<!--[if lt IE 7]> <html class="ie6 ie"> <![endif]-->
<!--[if IE 7]>    <html class="ie7 ie"> <![endif]-->
<!--[if IE 8]>    <html class="ie8 ie"> <![endif]-->
<!--[if IE 9]>    <html class="ie9 ie"> <![endif]-->
<!--[if !IE]> --> <html> <!-- <![endif]-->

<!-- Mirrored from seop.illc.uva.nl/entries/church/supplementD.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 22 Jun 2022 20:09:48 GMT -->
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>
Alonzo Church &gt; D. The &lambda;-Calculus and Type Theory (Stanford Encyclopedia of Philosophy)
</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="robots" content="noarchive, noodp" />
<meta name="DCTERMS.ispartof" content="https://plato.stanford.edu/entries/church/" />

<!-- NOTE: Import webfonts using this link: -->
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,600,200&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css" />

<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/bootstrap.min.css" />
<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/bootstrap-responsive.min.css" />
<link rel="stylesheet" type="text/css" href="../../css/font-awesome.min.css" />
<!--[if IE 7]> <link rel="stylesheet" type="text/css" href="../../css/font-awesome-ie7.min.css"> <![endif]-->
<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/style.css" />
<link rel="stylesheet" type="text/css" media="print" href="../../css/print.css" />
<link rel="stylesheet" type="text/css" href="../../css/entry.css" />
<!--[if IE]> <link rel="stylesheet" type="text/css" href="../../css/ie.css" /> <![endif]-->
<script type="text/javascript" src="../../js/jquery-1.9.1.min.js"></script>
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>

<!-- NOTE: Javascript for sticky behavior needed on article and ToC pages -->
<script type="text/javascript" src="../../js/jquery-scrolltofixed-min.js"></script>
<script type="text/javascript" src="../../js/entry.js"></script>

<!-- SEP custom script -->
<script type="text/javascript" src="../../js/sep.js"></script>
</head>

<!-- NOTE: The nojs class is removed from the page if javascript is enabled. Otherwise, it drives the display when there is no javascript. -->
<body class="nojs article" id="pagetopright">
<div id="container">
<div id="header-wrapper">
  <div id="header">
    <div id="branding">
      <div id="site-logo"><a href="../../index.html"><img src="../../symbols/sep-man-red.png" alt="SEP home page" /></a></div>
      <div id="site-title"><a href="../../index.html">Stanford Encyclopedia of Philosophy</a></div>
    </div>
    <div id="navigation">
      <div class="navbar">
        <div class="navbar-inner">
          <div class="container">
            <button class="btn btn-navbar collapsed" data-target=".collapse-main-menu" data-toggle="collapse" type="button"> <i class="icon-reorder"></i> Menu </button>
            <div class="nav-collapse collapse-main-menu in collapse">
              <ul class="nav">
                <li class="dropdown open"><a id="drop1" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-book"></i> Browse</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">
                    <li><a href="../../contents.html">Table of Contents</a></li>
                    <li><a href="../../new.html">What's New</a></li>
                    <li><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/random">Random Entry</a></li>
                    <li><a href="../../published.html">Chronological</a></li>
                    <li><a href="../../archives/index.html">Archives</a></li>
                  </ul>
                </li>
                <li class="dropdown open"><a id="drop2" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-info-sign"></i> About</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop2">
                    <li><a href="../../info.html">Editorial Information</a></li>
                    <li><a href="../../about.html">About the SEP</a></li>
                    <li><a href="../../board.html">Editorial Board</a></li>
                    <li><a href="../../cite.html">How to Cite the SEP</a></li>
                    <li><a href="../../special-characters.html">Special Characters</a></li>
                    <li><a href="../../tools/index.html">Advanced Tools</a></li>
                    <li><a href="../../contact.html">Contact</a></li>
                  </ul>
                </li>
                <li class="dropdown open"><a id="drop3" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-leaf"></i> Support SEP</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop3">
                    <li><a href="../../support/index.html">Support the SEP</a></li>
                    <li><a href="../../support/friends.html">PDFs for SEP Friends</a></li>
                    <li><a href="../../support/donate.html">Make a Donation</a></li>
                    <li><a href="../../support/sepia.html">SEPIA for Libraries</a></li>
                  </ul>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- End navigation -->
    
    <div id="search">
      <form id="search-form" method="get" action="https://seop.illc.uva.nl/search/searcher.py">
        <input type="search" name="query" placeholder="Search SEP" />
        <div class="search-btn-wrapper"><button class="btn search-btn" type="submit"><i class="icon-search"></i></button></div>
      </form>
    </div>
    <!-- End search --> 
    
  </div>
  <!-- End header --> 
</div>
<!-- End header wrapper -->

<div id="content">

<!-- Begin article sidebar -->
<div id="article-sidebar" class="sticky">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <button class="btn btn-navbar" data-target=".collapse-sidebar" data-toggle="collapse" type="button"> <i class="icon-reorder"></i> Entry Navigation </button>
        <div id="article-nav" class="nav-collapse collapse-sidebar in collapse">
          <ul class="nav">
            <li><a href="index.html">Back to Entry <i class="icon-external-link"></i></a></li>
            <li><a href="index.html#toc">Entry Contents <i class="icon-external-link"></i></a></li>
            <li><a href="index.html#Bib">Entry Bibliography <i class="icon-external-link"></i></a></li>
            <li><a href="index.html#Aca">Academic Tools <i class="icon-external-link"></i></a></li>
            <li><a href="https://leibniz.stanford.edu/friends/preview/church/">Friends PDF Preview <i class="icon-external-link"></i></a></li>
            <li><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=church">Author and Citation Info <i class="icon-external-link"></i></a> </li>
            <li><a href="#pagetopright" class="back-to-top">Back to Top <i class="icon-angle-up icon2x"></i></a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- End article sidebar --> 

<!-- NOTE: Article content must have two wrapper divs: id="article" and id="article-content" -->
<div id="article">
<div id="article-content">

<!-- BEGIN ARTICLE HTML -->
<h4 id="supphead">Supplement to <a href="index-2.html">Alonzo Church</a></h4>

<div id="aueditable">
<!--DO NOT MODIFY THIS LINE AND ABOVE--> 
<h2>D. The &lambda;-Calculus and Type Theory</h2>
<!--Entry Contents-->

<ul>

 <li><a href="#D1ChurLambCalc">D.1 Church&rsquo;s Lambda Calculus</a></li>
 
 <li><a href="#D2ChurSimpTheoType">D.2 Church&rsquo;s Simple Theory of Types</a></li>
 
 <li><a href="#D3RamiTheoType">D.3 The Ramified Theory of Types</a></li>
 </ul>
<!--Entry Contents-->

<hr />

<h3 id="D1ChurLambCalc">D.1 Church&rsquo;s Lambda Calculus</h3>

<p>
According to Church, a</p>

<blockquote>

<p>
function is a rule of correspondence by which when anything is given
(as argument) another thing (the value of the function for that
argument) may be obtained. (1941 [BE: 201])</p>
</blockquote>

<p>
The &lambda;-calculi are essentially a family of notations for
representing functions as such rules of correspondence rather than as
graphs (i.e., sets or classes of ordered pairs of arguments and
values).</p>

<p>
The &lambda;-operator is a monadic variable binding
&ldquo;abstraction&rdquo; operator that allows one to build complex
expressions that designate functions. For example, the occurrence of
the numerical successor function&mdash;henceforth
&ldquo;\(S(x)\)&rdquo;&mdash;in the form &ldquo;\(S(x) \gt
1000\)&rdquo; is meaningless until we pick a particular natural number
as the value for &ldquo;\(x\)&rdquo;. In contrast, the occurrence of
&ldquo;\(S(x)\)&rdquo; in the form &ldquo;\(S(x)\) is primitive
recursive&rdquo; <em>designates a particular function</em>. Using
&ldquo;&lambda;&rdquo; we can build an expression that designates this
function by writing</p> 

\[\lambda x [S(x)].\]

<p>
We can also introduce <em>n</em>-adic &lambda;-abstracts that
designate <em>n</em>-ary functions (or functions of \(n\) variables)
such as the dyadic</p> 

\[\lambda xy [x + y].\]

<p>
Complex predicates including those from natural language can also be
treated as functions&mdash;from individuals to truth values. For this
reason, &lambda;-abstracts have become part of the meta-language of
formal semantics.(see Partee et al. 1990 as well as Heim &amp; Kratzer
1998&mdash;two enormously influential textbooks). For example, from
the form &ldquo;\(x\) is a Polish diplomat and \(x\) is a great
pianist&rdquo;, we can obtain the corresponding complex predicate:</p>

\[
\lambda x[x \text{ is a Polish diplomat and } x \text{ is a great pianist}].
\]

<p>
Intuitively, this can be read as &ldquo;is an individual who is both a
Polish diplomat and a great pianist&rdquo;. One can also build
compound <em>n</em>-adic &lambda;-abstracts from compound formulas.
For example, from the form &ldquo;\(x\) is evenly divisible by \(y\)
and \(y\) is not evenly divisible by \(x\)&rdquo; one can obtain</p>

\[
\lambda xy[x \text{ is evenly divisible by } y \text{ and } y \text{ is not evenly divisible by } x].
\]

<p>
In general, for any expression (form, formula, term, definite
description, &lambda;-abstract) &Psi; and variables \(\ulcorner
\alpha_1,\ldots \alpha_n \urcorner\), one can obtain</p> 

\[ 
\lambda \alpha_1,\ldots \alpha_n [\Psi\alpha_1,\ldots \alpha_n]. 
\]

<p>
All such expressions are compound function expressions.</p>

<p>
However, instead of forming compound <em>n</em>-adic
&lambda;-abstracts that represent <em>n</em>-ary functions (or
functions of \(n\) variables), Church iterates monadic
&ldquo;&lambda;&rdquo; and reduces <em>n</em>-ary functions to
functions of one variable whose values are functions of \(n-1\)
variables. (This is the method known today as &ldquo;Currying&rdquo;,
for Haskell Curry, although the method is due to Moses
Sch&ouml;nfinkel; see Church 1941 [BE: 202&ndash;3].) Rather than
writing &ldquo;\(x + y\)&rdquo; for the function from pairs of natural
numbers to their sum we write &ldquo;\(((+ x) y)\)&rdquo;. For any
number \(x\), we want &ldquo;\(+ x\)&rdquo; to designate the function
of one variable that when applied to the value of this variable gives
another function \((+ x)\) that for any number \(y\) gives \(((+ x)
y)\), i.e., the sum of \(x\) and \(y\), and thus adds \(x\) to any
number \(y.\) In this way, we input each variable into a separate
function. Rather than using <em>n</em>-adic &ldquo;&lambda;&rdquo; and
writing</p> 

\[\lambda xy [x + y]\]

<p>
we use monadic &ldquo;&lambda;&rdquo; and write</p> 

\[\lambda x(\lambda y [+ x]y).\]

<p>
In this notation &ldquo;\(\lambda x (\lambda
y[+x]y)\)&rdquo; <em>designates</em> the function of one variable that
when applied to the value of &ldquo;\(x\)&rdquo;&mdash;say 1&mdash;as
argument gives another function designated by &ldquo;\(\lambda y [+
1]y\)&rdquo; that for any number \(y\) adds 1 to its argument. Since
the latter function is itself a function of one variable, we have
reduced the function \(\lambda xy [x + y]\) of \(n = 2\) variables to
a function of one variable whose value is a functions of \(n-1\)
variables.</p>

<p>
Having reduced <em>n</em>-adic &lambda;-abstraction to iterated
monadic &lambda;-abstraction, for any expression (form, formula, term,
definite description, &lambda;-abstract) &Psi; and variable
\(\ulcorner \alpha\urcorner\), we can write</p> 

\[\lambda \alpha [\Psi\alpha]\]

<p>
instead of</p> 

\[\lambda \alpha_1,\ldots \alpha_n [\Psi\alpha_1,\ldots \alpha_n].\]

<p>
Church sometimes adopts Russell&rsquo;s notational convention (PM)
that a dot placed before an expression brackets the expression.
&ldquo;\(\lambda \alpha [\Psi\alpha]\)&rdquo; is then the same
expression as</p> 

\[\lambda \alpha \hdot \Psi\alpha.\]

<p>
In general, this should be read as <em>the function that assigns &Psi;
to &alpha;</em>. When attached to a term, such an expression forms a
compound monadic predicative formula, as in</p> 

\[\lambda y \hdot + 1y\ 2\]

<div class="center">

<p>
\(\lambda x \hdot x\) is a Polish diplomat and \(x\) is a great
pianist <em>Paderewski</em>.</p>
</div>

<p>
In general, when \(\ulcorner \lambda \alpha \hdot
\Psi\alpha]\urcorner\) is combined with an argument expression
\(\beta\), it should be read as <em>the value of the function that
assigns &Psi; to &alpha; for \(\beta\) as argument.</em></p>

<p>
The elegance of the notation as a means for representing functions is
obvious. The identity function, which is defined as \(I\alpha=
\alpha\) for any argument \(\alpha,\) is represented by the abstract
\(\ulcorner \lambda \alpha \hdot \alpha\urcorner\). The function that
duplicates or replicates its own argument is represented by the
abstract \(\ulcorner \lambda \alpha \hdot \alpha\alpha\urcorner\)
(Church 1941 [BE: 202]). The constant function, which accepts &alpha;
as well as any second argument \(\beta\) but always maps &alpha; to
the same value regardless of \(\beta\), is represented by the abstract
\(\ulcorner \hhdot \lambda \alpha \hdot \lambda b \alpha \urcorner\).
(Note that Church sometimes adopts Russell&rsquo;s notational
convention (PM) that a greater number of dots indicates an outside
bracket, while a smaller number indicates an inside bracket.)</p>

<p>
&lambda;-abstracts are governed by three rules of inference:</p>

<ul>

<li>\(\alpha\)-conversion: alphabetic changes of bound variables</li>

<li>&lambda;-contraction: an occurrence of \(\ulcorner \lambda \alpha
\hdot \Psi\alpha \beta\urcorner\) within a formula is replaced with
one of \(\Psi\beta\)</li>

<li>&lambda;-expansion: an occurrence of \(\Psi\beta\) within a
formula is replaced with one of \(\ulcorner \lambda \alpha \hdot
\Psi\alpha \beta\urcorner\).</li>
</ul>

<p>
Regarding the last two rules, it is required that &Psi;&beta; be the
result of uniformly substituting free occurrences of \(\beta\) for
free occurrences of &alpha; throughout &Psi;&alpha;. These two rules
are together known as &ldquo;&lambda;-conversion&rdquo; (although
&ldquo;&lambda;-contraction&rdquo; is sometimes known as
&ldquo;\(\beta\)-reduction&rdquo; or &ldquo;&lambda;-concretion&rdquo; and
&ldquo;\(\alpha\)-conversion&rdquo; is sometimes known as
&ldquo;\(\alpha\)-reduction&rdquo;.) For example, from</p>

<div class="center">

<p>
Paderewski is a Polish diplomat and Paderewski is a great pianist</p>
</div>

<p>
we can infer by &lambda;-conversion</p>

<div class="center">

<p>
\(\lambda x \hdot x\) is a Polish diplomat and \(x\) is a great
pianist <em>Paderewski</em>,</p>
</div>

<p>
and vice versa. Similarly, from &ldquo;\(\lambda x \hdot x\ a\)&rdquo;
we can infer &ldquo;\(a\)&rdquo; and vice versa, while from
&ldquo;\(\lambda x \hdot xx\ a\)&rdquo; we can infer
&ldquo;\(aa\)&rdquo; and <em>vice versa</em>. Likewise, from
&ldquo;\(1 + 2\)&rdquo;, i.e., &ldquo;\(((+ 1) 2)\)&rdquo; we can
infer</p> 

\[ (\lambda  y [+ 1]y) 2\] \[\lambda x(\lambda  y [+ x]y)1, 2\]

<p>
and <em>vice versa</em>. Using our preferred notational
convention:</p> 

\[\lambda y \hdot + 1y 2\] \[\lambda x \hhdot \lambda y \hdot + x y 1 2.\]

<p>
The process of &lambda;-contraction terminates iff it results in an
expression in normal form, where an expression is in <em>normal
form</em> iff neither it nor any part of it is of the form \(\ulcorner
\lambda \alpha \hdot \Psi\alpha \beta \urcorner\). For example,
&ldquo;\(aa\)&rdquo; is the normal form of &ldquo;\(\lambda x \hdot xx
a\)&rdquo; while &ldquo;\(1 + 2\)&rdquo; is the normal form of
&ldquo;\(\lambda x \hhdot \lambda y \hdot+ x y 1 2\)&rdquo;. Some
expressions such as &ldquo;\(\hhdot \lambda x \hdot xx \hhdot \lambda
x \hdot xx\)&rdquo; have no normal form; in this case applying
&lambda;-contraction to the expression yields the very same expression
of the form \(\ulcorner \lambda \alpha \hdot \Psi\alpha \beta
\urcorner\), so the process of &lambda;-contraction does not
terminate.</p>

<p>
The above rule of alpha-conversion already allows that two distinct
expressions&mdash;say, &ldquo;\(\lambda x \hdot x a\)&rdquo; and
&ldquo;\(\lambda y \hdot y a\)&rdquo;&mdash;can represent the same
function. Much more interestingly, from each of &ldquo;\(\lambda x
\hdot x a\)&rdquo; and &ldquo;\(\hhdot \lambda y \hdot \lambda x \hdot
x y a\)&rdquo; we can, by &lambda;-conversion, infer \(a\), for any
argument \(a\); however, by the above rules we <em>cannot</em> infer
&ldquo;\(\lambda x \hdot x\) &rdquo; from &ldquo;\(\hhdot \lambda y
\hdot \lambda x \hdot x y\)&rdquo;. (It follows that if we restrict
ourselves to the above rules, then these two expressions are not
synonymous; cf.
 <a href="supplementE.html">supplement E</a>.)
 So we have <em>two distinct &lambda;-expressions that represent
distinct functions with the same graph</em>, which illustrates
Church&rsquo;s innovation of representing functions as rules of
correspondence (or functions in intension) rather than as graphs (or
functions in extension).</p>

<p>
However, the following are special cases of &lambda;-contraction and
expansion respectively, if &Psi; is a monadic predicate or function
symbol not containing any free occurrence of &alpha;:</p>

<ul>

<li>eta-contraction: an occurrence of \(\ulcorner \lambda \alpha \hdot
\Psi\alpha \urcorner\) within a formula can be replaced by one of
\(\Psi\alpha\)</li>

<li>eta-expansion: an occurrence of \(\Psi\alpha\) within a formula
can be replaced by one of \(\ulcorner \lambda \alpha \hdot \Psi\alpha
\urcorner\).</li>
</ul>

<p>
If we allow eta-contraction as a special case of &lambda;-contraction,
then we <em>can</em> infer &ldquo;\(\lambda x \hdot x\)&rdquo; from
&ldquo;\(\hhdot \lambda y \hdot \lambda x \hdot x y\)&rdquo;. More
generally, the theory becomes extensional because two closed
expressions in normal form are distinct iff they designate functions
that give different values for some argument and so have distinct
graphs. Computable functions with the same graph are no longer
distinct. For more information, see Hindley and Seldin (2008: ch.
7).</p>

<p>
Another difference between functions and their graphs is that in an
un-typed &lambda;-calculus compound function expressions can be
applied to themselves. For example, we can apply the identity function
to itself, as in &ldquo;\(\hhdot \lambda x \hdot x \hhdot \lambda x
\hdot x\)&rdquo;, and infer &ldquo;\(\lambda x \hdot x\)&rdquo;. We
can also apply the constant function to a first argument \(a\) and to
itself as the second argument, as in &ldquo;\(\hhdot \lambda x \hdot
\lambda yx a \hhdot \lambda x \hdot \lambda y x\)&rdquo;, and infer
&ldquo;\(a\)&rdquo;. However, if we were to identify such functions
with their graphs, we would have to allow graphs that can contain
themselves&mdash;something disallowed in conventional set theory by
the axiom of foundation.</p>

<p>
Given that compound function expressions can be applied to themselves,
we can obtain a formula that purports to designate the Russellian
function that does not apply to itself: &ldquo;\(\lambda \rF \hhdot
\neg \rF \hdot \rF\)&rdquo;, i.e., &ldquo;\(\lambda \rF (\neg
\rF[\rF])\)&rdquo;, which we shall call &ldquo;\(R\)&rdquo;. The
formula &ldquo;\(RR\)&rdquo; expresses that \(R\) applies to itself.
By the definition of &ldquo;\(R\)&rdquo; and &lambda;-conversion:</p>

\[RR \leftrightarrow \lambda \rF \hhdot \neg \rF \hdot \rF R\]

<p>
But then, by an application of &lambda;-contraction to the right hand
side, \(RR \leftrightarrow \neg \hdot RR\). However, Church originally
developed the &lambda;-calculus within an un-typed deductive system
that was supposed to provide a foundation for mathematics that avoided
this paradox (1932, 1933). Neither \(RR\) nor \(\neg \hdot RR\) can be
derived in the system of 1933, so the paradox cannot be obtained.</p>

<p>
Numerals and arithmetical operations can be represented in the
&lambda;-calculus. Church begins with the numeral &ldquo;1&rdquo;
(1941 [BE: 219]); but it is now common to begin with &ldquo;0&rdquo;
and we do so here. We begin with an arbitrary function \(f\). To
represent &ldquo;0&rdquo; we form a &lambda;-abstract that designates
\(f\) as well as the identity function with \(f\) unapplied:</p>

\[ 0 =_{\textit{df}} \lambda  f \hdot \lambda  x \hdot x\]

<p>
Intuitively speaking, the connection between the designatum of this
abstract and the familiar number 0 is that the identity function with
\(f\) unapplied will always return <em>x with nothing added to
it,</em> for any argument \(x.\)</p>

<p>
To represent 1 we designate the same function as before but with \(f\)
applied:</p> 

\[ 1 = \lambda  f \hdot \lambda  x \hdot fx\]

<p>
If \(g\) and \(h\) are functions, then there is another function that
results from applying \(g\) to the result of applying \(h.\) This is
designated by &ldquo;\(\lambda x \hdot g(hx)\)&rdquo; and is also
called &ldquo;the composition of \(g\) and \(h\)&rdquo;. For example,
where the function \(h = \lambda x \hdot x^2\) and the function \(g =
\lambda x \hdot x+1\), their composition \(= \lambda x \hdot x^2 + 1\)
(i.e., first we square the value of \(x\) and then we add 1 to the
result). To represent 2 we designate the function that when applied to
\(f\) as argument gives the composition of \(f\) and itself:</p>

\[2 = \lambda  f \hdot \lambda x \hdot f(fx)\]

<p>
We iterate this method to represent the rest of the natural
numbers:</p> 

\[\begin{align} 
3 &amp; = \lambda f \hdot \lambda x \hdot f(f(fx))\\ 
m &amp; = \lambda f \hdot \lambda x \hdot f \ldots . (f(fx)). 
\end{align}\]

<p>
As noted in
 <a href="supplementA.html">Supplement A</a>,
 these numerals as well as the notion of normal form are essential to
Church&rsquo;s basic undecidability argument.</p>

<p>
The forgoing explanation of &ldquo;the composition of \(g\) and
\(h\)&rdquo; took the function \(x+1\) for granted. This too can be
represented in in the &lambda;-calculus:</p> 

\[S(m) =_{\textit{df}} \lambda  y \hdot \lambda f \hdot \lambda x \hdot f (y f x) m\]

<p>
For example, by this definition and &lambda;-conversion</p>

\[\begin{align} 
S(0) &amp; = S(\lambda  f \hdot \lambda x \hdot x)\\ 
     &amp; = (\lambda y\hdot \lambda f \hdot \lambda x \hdot f(y f x )) (\lambda f \hdot \lambda x \hdot x) \\ 
     &amp; =\lambda f \hdot \lambda x \hdot fx\\ 
     &amp; = 1.
\end{align}\]

<p>
As Church remarks, this identification of the natural numbers with
certain functions is allowable because the functions form a
progression. Moreover, the arithmetical operations can also be
represented in the &lambda;-calculus (Church 1941 [BE: 220]).</p>

<p>
For further discussion of Church&rsquo;s untyped &lambda;-calculus see
 <a href="index-2.html#FounMath">section 5</a>.
 (See also Kleene [1981] as well as the entry on the
 <a href="../lambda-calculus/index.html">lambda calculus</a>
 and the
 <a href="../turing-machine/index.html#LDefi">section on &lambda;-definability in the entry on Turing Machines</a>.)</p>
 
<h3 id="D2ChurSimpTheoType">D.2 Church&rsquo;s Simple Theory of Types</h3>

<p>
There are two basic observations behind the theory of types, one of
which accords well with mathematical practice and the other with
common sense. The first observation is that numbers, sets of numbers,
sets of sets of numbers, functions, sets of functions, etc., are
entities of different types, where types themselves are reflected in
the language. This observation accurately reflects the practice of
mathematicians who already know the types of the entities that they
are thinking about when working in one or another subject area and who
will draw type distinctions when working in a more general framework,
like set theory, by using different kinds of symbols to designate
numbers (e.g., &ldquo;1&rdquo;, &ldquo;2&rdquo;,
&ldquo;3&rdquo;&hellip;, ), sets of numbers (e.g.,
&ldquo;\(\stN\)&rdquo;) and sets of sets of numbers (e.g.,
&ldquo;\(\cP(\stN)\)&rdquo;). The second observation is that entities
of a given type apply to entities of the highest type below their
type, so do not apply to entities of their own type. This can be seen
from the fact that while the expressions &ldquo;Paderewski is over 5
feet tall&rdquo;, &ldquo;Someone is over 5 feet tall&rdquo;, and
&ldquo;It is commonplace to be a person over 5 feet tall&rdquo; are
intelligible, &ldquo;Everyone Paderewski&rdquo;, &ldquo;Everyone
someone&rdquo;, and &ldquo;is over 5 feet tall is a commonplace
quality to have&rdquo; are all nonsense.</p>

<p>
However, Church formulates his simple theory of types (STT) in a way
that uses the &lambda;-calculus to represent the typed entities as
functions <em>qua</em> rules of correspondence rather than as sets or
classes (cf. previous section). All expressions of STT are assigned
types, which are the types of the entities that they designate.
&ldquo;\(\iota\)&rdquo; symbolizes the type of individuals,
&ldquo;\(o\)&rdquo; the type of truth values, and if &alpha; and
&beta; are type-symbols, then \(\ulcorner(\alpha\beta)\urcorner\) is
the type-symbol of the type of functions from entities of type &alpha;
to those of type &beta;. (Church writes this
\(\ulcorner(\beta\alpha)\urcorner\).) For example, &ldquo;\((\iota
o)\)&rdquo; symbolizes the type of functions from individuals to truth
values, and &ldquo;\((oo)\)&rdquo; symbolizes the type of functions
from truth values to truth values.</p>

<p>
According to STT, well-formed expressions are limited to:</p>

<ol type="i">

<li>Variables and constants of type &alpha;, for example
&ldquo;\(x_{\iota}\)&rdquo;, &ldquo;\(P_o\)&rdquo;, and
&ldquo;\(\neg_{(oo)}\)&rdquo;.</li>

<li>Complex expressions of type &beta; formed from expressions of type
&alpha; and those of type \((\alpha \beta)\), for example
&ldquo;\(\neg_{(oo)} P_o\)&rdquo;</li>

<li>&lambda;-abstracts of type \((\alpha \beta)\) formed from
variables of type &alpha; and expressions of type &beta;</li>
</ol>

<p>
As a result of these restrictions, in STT there is no type of
expressions &delta; formed only from expressions of type &delta;. It
follows that \(R\)&mdash;&ldquo;\(\lambda F \hhdot \neg F \hdot
F\)&rdquo;, i.e., &ldquo;\(\lambda F(\neg F[F])\)&rdquo;&mdash;is not
well formed, and so that Russell&rsquo;s paradox cannot arise.</p>

<p>
Church himself did not pursue the investigation of his STT in great
depth, but two remarkable students of his did: Leon Henkin and Peter
Andrews. Henkin developed what is now understood to be the model
theory for higher order logic. He introduced the distinction between
standard and non-standard models of STT and proved a completeness
theorem for validity defined in terms of non-standard models;
although, as a consequence of the incompleteness theorems, no such
theorem is possible for validity defined in terms of standard models
(see the entry on
 <a href="../type-theory-church/index.html">Church&rsquo;s type theory</a>
 for some details). Andrews first turned his attention to extending
STT to transfinite types, which allows for a more uniform development
of number and cardinality than in STT with only finite types; he then
developed the proof theory of STT with an emphasis on automated
reasoning. STT has inspired a lot of work on automation as well as on
the application of STT to natural language semantics, mathematics and
computer science, which is described in the entry on
 <a href="../type-theory-church/index.html">Church&rsquo;s type theory</a>.
 (By the way, Church [1960, 1962a] also made important contributions
to the theory of finite automata.)</p>

<p>
Regarding the denotational semantics for STT, this is considerably
more straightforward than that of un-typed &lambda;-calculi. See
Andrews (1986), which contains a lot of information about STT, much of
which is also contained in the entry on
 <a href="../type-theory-church/index.html">Church&rsquo;s type theory</a>.</p>
 
<p>
The expressive power of STT raises an important issue that pertains to
Church&rsquo;s objection to logicism as an economical foundation for
elementary arithmetic (an objection noted in
 <a href="index-2.html#FounMath">section 5</a>):</p>
 
<blockquote>

<p>
However, the higher-order predicate (or functional) variables,
together with comprehension principles which are required for them,
mean in the presence of an axiom of infinity that even the
non-denumerably infinite has been admitted. (1962 [BE: 611])</p>
</blockquote>

<p>
To understand this objection, it will be helpful to recall that the
expressive power of second-order logic is obtained by laying down
comprehension axioms, which are axioms stating that a formula &Phi;
defines a second-order entity in the domain of the higher-order
variables, such as a propositional function, or the characteristic
function of a class. It will also help to recall that these axioms
have the following form:</p> 

\[\exists P \forall x_1 \ldots x_n \hdot Px_1 \ldots x_n \leftrightarrow \Phi x_1 \ldots x_n\]

<p>
Now suppose that we want to define <em>complex</em> properties and
functions of individuals (so we are staying at the second order). To
do this we use the &lambda;-abstraction operator discussed above.
Then, by the axiom above, and recalling that in Church&rsquo;s system
<em>n</em>-ary functions reduce to particular cases of functions of
one variable, we can abstract the corresponding complex predicate, as
follows:</p> 

\[\lambda x\hdot \Phi x .\]

<p>
In the context of STT we need to proceed beyond second order logic, so
we need a more general comprehension axiom scheme stating that an
expression \(\Psi_{\beta}\) of any type \(\beta\) defines a complex
function \(u\) of type \(\ulcorner(\alpha\beta)\urcorner\), which does
not occur free in \(\Psi_\beta\):</p> 

\[\exists u_{(\alpha\beta)} \forall x_a \hdot u_{(\alpha\beta)} x_\alpha \approxB \Psi_\beta\]

<p>
(Since \(\Psi_{\beta}\) is of any type &beta;, we use boldface
&ldquo;\(\approxB\)&rdquo;, which reduces to
&ldquo;\(\leftrightarrow\)&rdquo; in case &Psi; is a formula, and to
identity in case &Psi; is a singular term. Further, since we now use
lowercase Greek letters as variables ranging over <em>types</em>, we
use &ldquo;\(x\)&rdquo;, &ldquo;\(u\)&rdquo;, &ldquo;\(y\)&rdquo; etc.
as meta-language variables.) We designate the function whose existence
is asserted directly above as</p> 

\[\lambda  x_\alpha \hdot \Psi_\beta x_\alpha\]

<p>
So we have the comprehension scheme</p> 

\[\forall x_\alpha \hhdot \lambda x_\alpha \hdot \Psi_\beta x_\alpha \approxB \Psi_\beta\]

<p>
More perspicuously, we can designate the aforementioned function</p>

\[\lambda x_\alpha \hdot \Psi_\beta\]

<p>
So the comprehension scheme becomes</p> 

\[\forall x_\alpha \hhdot \lambda x_\alpha \hdot \Psi_\beta \approxB \Psi_\beta\]

<p>
Corresponding to this axiom scheme, the &lambda;-conversion rule of
&lambda;-expansion licenses the replacement, within a formula, of any
occurrence of \(\Psi_\beta\) by the &lambda;-abstract \(\ulcorner
\lambda x_\alpha \hdot \Psi_\beta y_\alpha\urcorner\). The rule of
&lambda;-contraction licenses the reverse replacement. Notice that
that \(x_\alpha\) and \(y_\alpha\) are required to be of the same
syntactic type.</p>

<p>
Church&rsquo;s worry about logicism can be appreciated by asking the
following question. <em>What are the possible values of the
higher-order variables in the aforementioned comprehension axioms,
under their classical extensional interpretation</em>? To which the
usual answer is that any given second-order variable
&ldquo;\(F\)&rdquo; ranges over <em>all sub-classes</em> of the domain
of individuals that &ldquo;\(F\)&rdquo; is true of. Further, any axiom
of infinity implies that there are infinitely many individuals. In
which case, any given second-order variable &ldquo;\(F\)&rdquo; ranges
over <em>all sub-classes</em> of an infinite class, which is
equivalent to the powerset of natural numbers \(\cP(\stN)\). Thus, as
Church remarked, &ldquo;the non-denumerably infinite has been
admitted&rdquo; (1962 [BE: 611]). This discredits logicism as an
economical foundation for elementary arithmetic.</p>

<p>
More important for Church&rsquo;s purposes than the status of logicism
is the relationship between the Simple and the Ramified theories of
types as described in Church (1976).</p>

<h3 id="D3RamiTheoType">D.3 The Ramified Theory of Types</h3>

<p>
The motivation for ramification is to resolve all paradoxes: not only
Russell&rsquo;s but also the semantical paradoxes such as
Grelling&rsquo;s Paradox (GP) and the Russell-Myhill Paradox (RM),
which are discussed in
 <a href="index-2.html#FounMath">section 4</a>.
 (Other semantical paradoxes addressed by ramification are those of
Epimenides and Richard.) Although these semantical paradoxes do not
arise in STT <em>per se</em>, they do arise in STT with the addition
of a semantical predicate. Further, they can be solved&mdash;as
Russell (1905; PM) discovered&mdash;by further stratifying each type.
Intuitively, the idea is as follows:</p>

<p>
Individuals have certain attributes such as <em>having brown
hair</em>. Suppose that some attributes are such that <em>all</em> the
children of a person who has these attributes also have them. These
attributes are <em>hereditary</em>, and so we discern the attribute of
attributes of <em>being hereditary</em>. Further suppose that some
individuals have <em>all of</em> the aforementioned person&rsquo;s
hereditary attributes. Here, &ldquo;all&rdquo; quantifies over
attributes that have the attribute of <em>being hereditary</em>.
Finally, suppose that we define the aforementioned person&rsquo;s
<em>descendants</em> as the individuals (including that very person)
who possess all of her hereditary attributes. As Poincar&eacute;
(1906) and Russell (1905; PM) pointed out, such
&ldquo;impredicative&rdquo; definitions display a kind of circularity.
In the present case, we have helped ourselves to the notion of <em>all
of her hereditary attributes</em> to define the notion of <em>her
descendants</em> where <em>being her descendants</em> is itself one of
her hereditary attributes. From the perspective of STT, it is
perfectly legitimate to define expressions of lower type by using
expressions of higher type. However, as we will see, from the point of
view of ramified type theory (RTT) such definitions are illegitimate.
(See also the entries on Poincar&eacute; and on Russell&rsquo;s
paradox.)</p>

<p>
Although it is helpful to have a prior understanding of STT in order
to understand RTT, strictly speaking the type-theoretic notions
involved are different. For this reason we adopt Church&rsquo;s policy
of renaming the types &ldquo;<em>r</em>-types&rdquo; and using
slightly different notation. Individual variables and names are
assigned the type &ldquo;\(i\)&rdquo;. Expressions are also assigned
<em>levels</em>, represented by Hindu-Arabic numerals. Individual
variables, names of individuals and names of propositions are of level
0. As for function expressions, these are assigned <em>r</em>-types as
follows. If &beta; is an <em>r</em>-type symbol, then
\(\ulcorner(\beta)/n\urcorner\) is the <em>r</em>-type symbol of all
function expressions of level \(n\) (where \(n \gt 1\), because only
individuals and propositions are of level 0). For example, a function
expression that takes individual variables and names, as well as
functions, as its arguments has the <em>r</em>-type \((i (i))/n\).
Further, \(\ulcorner(\alpha)/k\urcorner\) (where \(k \lt n\)) is of
the level <em>directly lower than</em> \(\ulcorner(\beta)/n\urcorner\)
if \(\ulcorner(\alpha) = (\beta)\urcorner\).</p>

<p>
More generally (where \(m \ge 0)\), if \(\ulcorner \beta 1,\ldots
\beta m\urcorner\) are <em>r</em>-type symbols, then \(\ulcorner(\beta
1,\ldots \beta m)/n\urcorner\) is the <em>r</em>-type symbol of all
(m-place) function expressions of <em>level</em> n (where \(n \gt
1)\). Further, \(\ulcorner(\alpha 1,\ldots \alpha m)/k\urcorner\)
(where \(k \lt n\)) is of the level <em>directly lower than</em>
\(\ulcorner (\beta 1,\ldots \beta m)/n\urcorner\) if \(\ulcorner
\alpha 1 = \beta 1\urcorner\),&hellip; \(\ulcorner \alpha m = \beta
m\urcorner\). For \(\ulcorner(\beta 1,\ldots \beta 3)/n\urcorner\),
Church uses the abbreviation &ldquo;\(3/n\)&rdquo; and, more
generally, \(\ulcorner(\beta 1,\ldots \beta m)/n\urcorner\), is
abbreviated &ldquo;\(m/n\)&rdquo;.</p>

<p>
To return to our example, &ldquo;\(i\)&rdquo; is attached to the
individual variables &ldquo;\(x\)&rdquo;, &ldquo;\(y\)&rdquo;, that
range over our descendants; these variables are also of level 0. By
the above, the function expression &ldquo;\(x\) has brown eyes&rdquo;
is <em>r</em>-typed &ldquo;\(x\) has brown eyes&rdquo;\(^{(i)/1}\).
Similarly, &ldquo;\(x\) is a descendant of \(y\)&rdquo; is
<em>r</em>-typed &ldquo;\(x\) is a descendant of \(y\)&rdquo;\(^{(ii)/1}\).
Levels are <em>cumulative,</em> in the sense that the range of
variables of each <em>r</em>-type includes the range of every variable
of directly lower <em>r</em>-type.</p>

<p>
Next, <em>orders</em> are defined as follows. The order of individual
variables and names is 0. In the case of function expressions, the
order of a variable of <em>r</em>-type \(\ulcorner (\beta 1,\ldots
\beta m)/n\urcorner\) is <em>the sum of n and the highest of the
orders of the variables</em> \(\ulcorner \beta \beta m\urcorner\)
(reflecting that the levels are cumulative).</p>

<p>
Now we can put all this together and apply it to our original example.
In an <em>un</em>-typed language we can define <em>F is
hereditary</em> as follows:</p> 

\[ \textrm{Hereditary}(F, R) \equiv_{\textit{df}} Fx \supset_x Rxy \supset_y Fy \]

<p>
(Note the notational convention that a connective can take a variable
as subscript: that variable becomes a universal quantifier whose scope
is precisely that of the connective.) In the present framework, since
&ldquo;\(x\)&rdquo; and &ldquo;\(y\)&rdquo; are of level 0, while
&ldquo;\(F\)&rdquo; and &ldquo;\(R\)&rdquo; are of level 1,
&ldquo;\(F\)&rdquo; and &ldquo;\(R\)&rdquo; are also of order 1 (i.e.,
the sum of 0 and 1). Further, since Church&rsquo;s notational variant
of &ldquo;\(\forall\)&rdquo; takes a name of a proposition as its
argument, it is also of level 1 and order 1. Furthermore, there are no
other argument expression in the definiens that are of a higher order
than 1. Therefore, the level of Hereditary\((F, R)\) is 2 and its
order is 3, which is the sum of 2 (its level) and 1 (the greatest of
the orders of its arguments).</p>

<p>
Finally, there is the restriction that for a function expression to be
well formed, the highest order of any expression in the
<em>definiens</em> must be of an order directly lower than the level
of the <em>definiendum</em>. While this does not prohibit our
definition of &ldquo;\(\textrm{Hereditary}^{2/2}(F^{1/1},
R^{2/1})\)&rdquo;, it does prohibit using it in the aforementioned
&ldquo;impredicative&rdquo; definition of &ldquo;\(x\) is a
descendant\(^{1/1}\)&rdquo;, since this function expression is of
level 1. As will become clear in
 <a href="index-2.html#LogiIntu">section 4.3</a>
 and
 <a href="index-2.html#SignGdelTheoContProb">section 4.4</a>,
 the solutions to GA and RM emerge from the apparatus of ramified
types.</p>

<p>
Crucially, if we drop the level indicators entirely, then the orders
of a given function expression become simply the highest of the orders
of its arguments. In that case, the orders become simple types, i.e.,
the &ldquo;orders&rdquo; of contemporary &ldquo;first order&rdquo; and
&ldquo;higher order&rdquo; logic. The reason is that in first order
logic, the highest of the orders of the variables (i.e., of
&ldquo;\(x\)&rdquo; &ldquo;\(F\)&rdquo;, &ldquo;\(R\)&rdquo; etc.) is
1. Further, in second order logic, the highest of the orders of the
variables (ranging over attributes of attributes such as <em>being
hereditary</em>) is 2. Note that the resulting simple type theory in
Church&rsquo;s (1974b) is not formulated in a &lambda;-calculus. (For
more on Church&rsquo;s formulation of RTT, see the entries on
 <a href="../pm-notation/index.html#RamiType">the notation for <em>Principia Mathematica</em> 5.2</a>
 and on
 <a href="../principia-mathematica/index.html#RamiTheoType"><em>Principia Mathematica</em> 4.1.2</a>.)</p>
<script type="text/javascript" src="local.js"></script>
<script type="text/javascript" src="../../MathJax/MathJaxb198.js?config=TeX-MML-AM_CHTML"></script>


</div><!-- #aueditable --><!--DO NOT MODIFY THIS LINE AND BELOW-->

<!-- END ARTICLE HTML -->

</div> <!-- End article-content -->

  <div id="article-copyright">
    <p>
 <a href="../../info.html#c">Copyright &copy; 2022</a> by

<br />
Harry Deutsch
&lt;<a href="m&#97;ilto:hdeutsch&#37;40ilstu&#37;2eedu"><em>hdeutsch<abbr title=" at ">&#64;</abbr>ilstu<abbr title=" dot ">&#46;</abbr>edu</em></a>&gt;<br />
Oliver Marshall
&lt;<a href="m&#97;ilto:Omarshall&#37;40gradcenter&#37;2ecuny&#37;2eedu"><em>Omarshall<abbr title=" at ">&#64;</abbr>gradcenter<abbr title=" dot ">&#46;</abbr>cuny<abbr title=" dot ">&#46;</abbr>edu</em></a>&gt;
    </p>
  </div>

</div> <!-- End article -->

<!-- NOTE: article banner is outside of the id="article" div. -->
<div id="article-banner" class="scroll-block">
  <div id="article-banner-content">
    <a href="../../fundraising/index.html">
    Open access to the SEP is made possible by a world-wide funding initiative.<br />
    The Encyclopedia Now Needs Your Support<br />
    Please Read How You Can Help Keep the Encyclopedia Free</a>
  </div>
</div> <!-- End article-banner -->

    </div> <!-- End content -->

    <div id="footer">

      <div id="footer-menu">
        <div class="menu-block">
          <h4><i class="icon-book"></i> Browse</h4>
          <ul role="menu">
            <li><a href="../../contents.html">Table of Contents</a></li>
            <li><a href="../../new.html">What's New</a></li>
            <li><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/random">Random Entry</a></li>
            <li><a href="../../published.html">Chronological</a></li>
            <li><a href="../../archives/index.html">Archives</a></li>
          </ul>
        </div>
        <div class="menu-block">
          <h4><i class="icon-info-sign"></i> About</h4>
          <ul role="menu">
            <li><a href="../../info.html">Editorial Information</a></li>
            <li><a href="../../about.html">About the SEP</a></li>
            <li><a href="../../board.html">Editorial Board</a></li>
            <li><a href="../../cite.html">How to Cite the SEP</a></li>
            <li><a href="../../special-characters.html">Special Characters</a></li>
            <li><a href="../../tools/index.html">Advanced Tools</a></li>
            <li><a href="../../contact.html">Contact</a></li>
          </ul>
        </div>
        <div class="menu-block">
          <h4><i class="icon-leaf"></i> Support SEP</h4>
          <ul role="menu">
            <li><a href="../../support/index.html">Support the SEP</a></li>
            <li><a href="../../support/friends.html">PDFs for SEP Friends</a></li>
            <li><a href="../../support/donate.html">Make a Donation</a></li>
            <li><a href="../../support/sepia.html">SEPIA for Libraries</a></li>
          </ul>
        </div>
      </div> <!-- End footer menu -->

      <div id="mirrors">
        <div id="mirror-info">
          <h4><i class="icon-globe"></i> Mirror Sites</h4>
          <p>View this site from another server:</p>
        </div>
        <div class="btn-group open">
          <a class="btn dropdown-toggle" data-toggle="dropdown" href="https://plato.stanford.edu/">
            <span class="flag flag-usa"></span> USA (Main Site) <span class="caret"></span>
            <span class="mirror-source">Philosophy, Stanford University</span>
          </a>
          <ul class="dropdown-menu">
            <li><a href="../../mirrors.html">Info about mirror sites</a></li>
          </ul>
        </div>
      </div> <!-- End mirrors -->
      
      <div id="site-credits">
        <p>The Stanford Encyclopedia of Philosophy is <a href="../../info.html#c">copyright &copy; 2022</a> by <a href="http://mally.stanford.edu/">The Metaphysics Research Lab</a>, Department of Philosophy, Stanford University</p>
        <p>Library of Congress Catalog Data: ISSN 1095-5054</p>
      </div> <!-- End site credits -->

    </div> <!-- End footer -->

  </div> <!-- End container -->

   <!-- NOTE: Script required for drop-down button to work (mirrors). -->
  <script>
    $('.dropdown-toggle').dropdown();
  </script>

</body>

<!-- Mirrored from seop.illc.uva.nl/entries/church/supplementD.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 22 Jun 2022 20:09:48 GMT -->
</html>
