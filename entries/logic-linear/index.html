<!DOCTYPE html>
<!--[if lt IE 7]> <html class="ie6 ie"> <![endif]-->
<!--[if IE 7]>    <html class="ie7 ie"> <![endif]-->
<!--[if IE 8]>    <html class="ie8 ie"> <![endif]-->
<!--[if IE 9]>    <html class="ie9 ie"> <![endif]-->
<!--[if !IE]> --> <html> <!-- <![endif]-->

<!-- Mirrored from seop.illc.uva.nl/entries/logic-linear/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 22 Jun 2022 19:51:20 GMT -->
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>
Linear Logic (Stanford Encyclopedia of Philosophy)
</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="robots" content="noarchive, noodp" />
<meta property="citation_title" content="Linear Logic" />
<meta property="citation_author" content="Di Cosmo, Roberto" />
<meta property="citation_author" content="Miller, Dale" />
<meta property="citation_publication_date" content="2006/09/06" />
<meta name="DC.title" content="Linear Logic" />
<meta name="DC.creator" content="Di Cosmo, Roberto" />
<meta name="DC.creator" content="Miller, Dale" />
<meta name="DCTERMS.issued" content="2006-09-06" />
<meta name="DCTERMS.modified" content="2019-05-24" />

<!-- NOTE: Import webfonts using this link: -->
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,600,200&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css" />

<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/bootstrap.min.css" />
<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/bootstrap-responsive.min.css" />
<link rel="stylesheet" type="text/css" href="../../css/font-awesome.min.css" />
<!--[if IE 7]> <link rel="stylesheet" type="text/css" href="../../css/font-awesome-ie7.min.css"> <![endif]-->
<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/style.css" />
<link rel="stylesheet" type="text/css" media="print" href="../../css/print.css" />
<link rel="stylesheet" type="text/css" href="../../css/entry.css" />
<!--[if IE]> <link rel="stylesheet" type="text/css" href="../../css/ie.css" /> <![endif]-->
<script type="text/javascript" src="../../js/jquery-1.9.1.min.js"></script>
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>

<!-- NOTE: Javascript for sticky behavior needed on article and ToC pages -->
<script type="text/javascript" src="../../js/jquery-scrolltofixed-min.js"></script>
<script type="text/javascript" src="../../js/entry.js"></script>

<!-- SEP custom script -->
<script type="text/javascript" src="../../js/sep.js"></script>
</head>

<!-- NOTE: The nojs class is removed from the page if javascript is enabled. Otherwise, it drives the display when there is no javascript. -->
<body class="nojs article" id="pagetopright">
<div id="container">
<div id="header-wrapper">
  <div id="header">
    <div id="branding">
      <div id="site-logo"><a href="../../index.html"><img src="../../symbols/sep-man-red.png" alt="SEP logo" /></a></div>
      <div id="site-title"><a href="../../index.html">Stanford Encyclopedia of Philosophy</a></div>
    </div>
    <div id="navigation">
      <div class="navbar">
        <div class="navbar-inner">
          <div class="container">
            <button class="btn btn-navbar collapsed" data-target=".collapse-main-menu" data-toggle="collapse" type="button"> <i class="icon-reorder"></i> Menu </button>
            <div class="nav-collapse collapse-main-menu in collapse">
              <ul class="nav">
                <li class="dropdown open"><a id="drop1" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-book"></i> Browse</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">
                    <li><a href="../../contents.html">Table of Contents</a></li>
                    <li><a href="../../new.html">What's New</a></li>
                    <li><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/random">Random Entry</a></li>
                    <li><a href="../../published.html">Chronological</a></li>
                    <li><a href="../../archives/index.html">Archives</a></li>
                  </ul>
                </li>
                <li class="dropdown open"><a id="drop2" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-info-sign"></i> About</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop2">
                    <li><a href="../../info.html">Editorial Information</a></li>
                    <li><a href="../../about.html">About the SEP</a></li>
                    <li><a href="../../board.html">Editorial Board</a></li>
                    <li><a href="../../cite.html">How to Cite the SEP</a></li>
                    <li><a href="../../special-characters.html">Special Characters</a></li>
                    <li><a href="../../tools/index.html">Advanced Tools</a></li>
                    <li><a href="../../contact.html">Contact</a></li>
                  </ul>
                </li>
                <li class="dropdown open"><a id="drop3" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-leaf"></i> Support SEP</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop3">
                    <li><a href="../../support/index.html">Support the SEP</a></li>
                    <li><a href="../../support/friends.html">PDFs for SEP Friends</a></li>
                    <li><a href="../../support/donate.html">Make a Donation</a></li>
                    <li><a href="../../support/sepia.html">SEPIA for Libraries</a></li>
                  </ul>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- End navigation -->
    
    <div id="search">
      <form id="search-form" method="get" action="https://seop.illc.uva.nl/search/searcher.py">
        <input type="search" name="query" placeholder="Search SEP" />
        <div class="search-btn-wrapper"><button class="btn search-btn" type="submit"><i class="icon-search"></i></button></div>
      </form>
    </div>
    <!-- End search --> 
    
  </div>
  <!-- End header --> 
</div>
<!-- End header wrapper -->

<div id="content">

<!-- Begin article sidebar -->
<div id="article-sidebar" class="sticky">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <button class="btn btn-navbar" data-target=".collapse-sidebar" data-toggle="collapse" type="button"> <i class="icon-reorder"></i> Entry Navigation </button>
        <div id="article-nav" class="nav-collapse collapse-sidebar in collapse">
          <ul class="nav">
            <li><a href="#toc">Entry Contents</a></li>
            <li><a href="#Bib">Bibliography</a></li>
            <li><a href="#Aca">Academic Tools</a></li>
            <li><a href="https://leibniz.stanford.edu/friends/preview/logic-linear/">Friends PDF Preview <i class="icon-external-link"></i></a></li>
            <li><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=logic-linear">Author and Citation Info <i class="icon-external-link"></i></a> </li>
            <li><a href="#pagetopright" class="back-to-top">Back to Top <i class="icon-angle-up icon2x"></i></a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- End article sidebar --> 

<!-- NOTE: Article content must have two wrapper divs: id="article" and id="article-content" -->
<div id="article">
<div id="article-content">

<!-- BEGIN ARTICLE HTML -->


<div id="aueditable"><!--DO NOT MODIFY THIS LINE AND ABOVE-->

<h1>Linear Logic</h1><div id="pubinfo"><em>First published Wed Sep 6, 2006; substantive revision Fri May 24, 2019</em></div>

<div id="preamble">

<p>

Linear logic is a refinement of classical and intuitionistic logic.
Instead of emphasizing <em>truth</em>, as in classical logic, or
<em>proof</em>, as in intuitionistic logic, linear logic emphasizes the
role of formulas as <em>resources</em>. To achieve this focus, linear
logic does not allow the usual structural rules of contraction and
weakening to apply to all formulas but only those formulas marked with
certain modals. Linear logic contains a fully involutive negation while
maintaining a strong constructive interpretation. Linear logic also
provides new insights into the nature of proofs in both classical and
intuitionistic logic. Given its focus on resources, linear logic has
found many applications in Computer Science.</p>

</div>

<div id="toc">
<!--Entry Contents-->
<ul>
<li><a href="#Int">1. Introduction</a>
 <ul>
 <li><a href="#BitHis">1.1 A bit of history</a></li>
 <li><a href="#LinLogComSci">1.2 Linear logic and computer science</a></li>
 </ul></li>
<li><a href="#ProSys">2. Proof Systems</a>
 <ul>
 <li><a href="#SeqCal">2.1 Sequent calculus</a></li>
 <li><a href="#FocProSea">2.2 Focused proof search</a></li>
 <li><a href="#ProNet">2.3 Proof nets</a></li>
 </ul></li>
<li><a href="#Sem">3. Semantics</a>
 <ul>
 <li><a href="#SemProv">3.1 Semantics of provability </a></li>
 <li><a href="#SemProo">3.2 Semantics of proofs </a></li>
 </ul></li>
<li><a href="#Com">4. Complexity</a></li>
<li><a href="#ComSciImp">5. Computer science impact</a>
 <ul>
 <li><a href="#ProNor">5.1 Proof normalization</a></li>
 <li><a href="#ProSea">5.2 Proof search</a></li>
 </ul></li>
<li><a href="#Var">6. Variations</a>
 <ul>
 <li><a href="#DifTreMod">6.1 Different treatments of modality</a></li>
 <li><a href="#NonComLinLog">6.2 Non-commutative linear logic</a></li>
 <li><a href="#unbounded">6.3 Treatment of unbounded behavior</a></li>
 </ul></li>
<li><a href="#Bib">Bibliography</a></li>
<li><a href="#Aca">Academic Tools</a></li>
<li><a href="#Oth">Other Internet Resources</a></li>
<li><a href="#Rel">Related Entries</a></li>
</ul>
<!--Entry Contents-->

<hr />

</div>

<div id="main-text">

<h2><a name="Int">1. Introduction</a></h2>

<h3><a name="BitHis">1.1 A bit of history</a></h3>

<p>

Linear logic was introduced by Jean-Yves Girard in his
seminal work
(<a href="#girard87tcs">Girard 1987</a>).
 While the origin of the discovery of this new logic comes from a
semantical analysis of the models of System F (or polymorphic \(\lambda\)-calculus), 
one can see the whole system of linear logic as a bold
attempt to reconcile the beauty and symmetry of the systems for
classical logic with the quest for constructive proofs that had led to
intuitionistic logic.</p>

<p>

Indeed, one could present a fragment of linear logic, known as
<em>multiplicative additive linear logic</em> (MALL), as the outcome
of two simple observations.</p>

<ul> <li>In the sequent calculus presentation of classical logic, the
rules for the connectives &ldquo;<em>and</em>&rdquo; and
&ldquo;<em>or</em>&rdquo;, as well as the Cut rule and the rule for
implication may be presented equivalently in an additive form (the
context of the premises are the same) or a multiplicative form (the
context of the premises are different). These two presentations are
equivalent, in classical logic, because of the availability of a few
so-called &ldquo;structural&rdquo; rules, namely, contraction and
weakening.</li>

<li>The non-constructive proofs that one can perform in classical logic
actually use, in the sequent calculus presentation, one or the other of
these structural rules.</li>
</ul>

<p>

So, if we want to eliminate the non-constructive proofs without
destroying the symmetry of the sequent calculus, as is done in
intuitionistic logic, we can try to eliminate the contraction and
weakening rules instead. In doing so, we are left with two different
versions of each connective: an additive version and a multiplicative
version of conjunction and of disjunction. These different versions
of the same connecitve are now no longer equivalent. These new
connectives are &amp; (&ldquo;with&rdquo;, additive <em>and</em>),
\(\oplus\) (&ldquo;plus&rdquo;, additive <em>or</em>, \(\otimes\)
(&ldquo;tensor&rdquo;, multiplicative <em>and</em>) and \(\lpar\)
(&ldquo;par&rdquo;, multiplicative <em>or</em>).</p>

<p>
This duplication of the connectives actually leads to a much clearer
understanding of the conflict between classical and intuitionistic
logic. For example, the law of excluded middle (\(A\) <em>or</em>
not-\(A\)) is considered valid in the classical world and absurd in
the intuitionistic one. But in linear logic, this law has two
readings: the additive version \((A \oplus \neg A)\) is not provable
and corresponds to the intuitionistic reading of disjunction; the
multiplicative version \((A \lpar \neg A)\) is trivially provable and
simply corresponds to the tautology \((A\)
<em>implies</em> \(A)\) that is perfectly acceptable in
intuitionistic logic too.</p>

<p>

Also, the disjunction property, essential in constructivism, is
easily established for the additive disjunction.</p>

<p>

We find then inside this richer logic a way to represent both the
needs of intuitionism and the elegance of classical logic: negation is
involutive, sequents are symmetric, and connectives are inter-definable.
Contrast these properties with those of intuitionistic logic,
where negation is not involutive, sequents are not symmetric, and
connectives are all not inter-definable.</p>

<p>

Notice though that once one has eliminated the contraction and
weakening rule, formulas no longer behave as immutable truth values:
indeed, when we have a proof of \(A \Rightarrow B\) and a
proof of \(A\) in linear logic, by composing them we actually
consume them to get a proof of \(B\), so that \(A \Rightarrow B\) and \(A\) are no longer available after the
composition. Linear logic formulas behave now more like
<em>resources</em> that can only be used once.</p>

<p>

To recover the full expressive power of intuitionistic and classical
logic, it is then necessary to add to the MALL fragment two dual
modalities, which are usually called <em>exponentials</em> in the
linear logic literature. In particular, the &ldquo;of-course&rdquo;
exponential \(\bang\) permits contraction and weakening to be
applied to the formula \(\bang B\) in the left-hand sequent context
while the &ldquo;why-not&rdquo; exponential
\(\quest\) permits contraction and weakening to be applied to
the formula \(\quest B\) on the right-hand sequent context. This
leads to the full propositional linear logic and to a very nice
connection with computer science.</p>

<p>
Notice that besides MALL, there are two other widely used fragments of
Linear Logic: Multiplicative Linear Logic (MLL), which is MALL without
the additive connectives; and Multiplicative Exponential Linear Logic
(MELL), which is Linear Logic without the additive connectives.
</p>

<p>
Prior to the introduction of linear logic in 1987, various researchers
had been working on various kinds of substructural logic in which not
all of Gentzen&rsquo;s structural rules (contraction, weakening, and
exchange) are accepted. Lambek studied a sequent calculus proof
systems in which none of these structural rules were permitted (<a
href="#lambek58amm">Lambek 1958</a>).
Other examples of such logics are relevant logic (in which weakening
is not accepted)
(<a href="#avron88tcs">Avron 1988</a>, <a href="#read88">Read 1988</a>).
and affine logic (in which contraction is not accepted)
(<a href="#grishin81">Grishin 1981</a>).
</p>

<h3><a name="LinLogComSci">1.2 Linear logic and computer science</a></h3>

<p>

Proof-theory is focused on formal proof systems and such formal
systems have been developed for intuitionistic predicate calculus,
classical predicate calculus, arithmetics, higher-order calculi, among
many others. Intuitionistic and constructive logic began when people
saw the possibility of reading &lsquo;\(A \Rightarrow B\)&rsquo; as
&lsquo;if you give me an \(A\), I will give you a \(B\)&rsquo;, which
is a significant departure from the classical reading &lsquo;\(A\) is
false or \(B\) is true&rsquo;.</p>

<p>

Computer science, on the other hand, focuses on computational
mechanisms: function application, exception handling, method
invocation in object-oriented languages, variable assignment and
similar sets of process-building rules. Except that the mechanisms of
these processes have to be made explicit: a function of type \(A
\rightarrow B\) gives a formal account of how to transform an \(A\)
into a \(B\).</p>

<p>

At a given moment these two senses met. H. B. Curry and W. Howard
realized that the set of implication-only <em>intuitionistic</em>
deductions was a core functional language called simply-typed
\(\lambda\)-calculus: the programming language was a logic, the logic a
programming language. This memorable meeting was called the
&lsquo;Curry-Howard isomorphism&rsquo; 
(<a href="#howard80">Howard 1980</a>).</p>

<p>

Linear logic provides a further twist in the interpretation of the implication
&lsquo;\(A \Rightarrow B\)&rsquo;: now it can be read as &lsquo;give me
<em>as many</em> \(A\)'s as I might need and I will give you
<em>one</em> \(B\)&rsquo;. The notion of <em>copy</em> which is
so central to the idea of computation is now wired into the logic.
</p>

<p>

This new viewpoint opens up new possibilities, including:</p>

<ul>

<li><em>new formulas</em> expressing refined operational properties
like &lsquo;give me \(A\) once and I will give you
\(B\)&rsquo;. Applications here range from refined logic programming
where the ability of linear logic to represent states is put to use
(<a href="#hodas94ic">Hodas &amp; Miller, 1994</a>), to the analysis
of classical logic and computational interpretations thereof
(<a href="#abramsky93tcs">Abramsky 1993</a>), to the specification of
exception mechanisms in programming languages
(<a href="#miller96tcs">Miller, 1996</a>), to linearity analysis
(<a href="#wadler91pepm">Wadler, 1991</a>).</li>

<li><em>new rules</em> expressing constraints on the use of copies
resulting in a fragment of linear logic for polytime computations to
mention only the most spectacular application 
(<a href="#baillot04lics">Baillot &amp; Terui, 2004</a>, 
<a href="#baillot15ic">Baillot 2015</a>).</li>

<li><em>new ways</em> of representing proofs
(<a href="#abramsky94ic">Abramsky &amp; Jagadeesan, 1994</a>,
<a href="#girard87tcs">Girard 1987</a>).
</li>
</ul>

<h2><a name="ProSys">2. Proof Systems</a></h2>

<p>

The core propositional connectives of linear logic are divided into
additive and multiplicative connectives. The classical conjunction and
its identity, \(\wedge\) and \(\top\), split into the additive
\(\amp\) (with) and \(\top\) (top) and the multiplicative \(\otimes\)
(tensor) and 1 (one). Similarly, the classical disjunction and its
identity, \(\vee\) and \(\bot\), split into the additive \(\oplus\)
(oplus) and 0 (zero) and the multiplicative \(\lpar\) (par) and
\(\bot\) (bottom). Negation is generally treated in one of two ways in
presentations a linear logic. Negation can be viewed as a primitive
propositional connective with no restrictions on its occurrences
within formulas. Since De Morgan dualities exist between negation and
all propositional connectives, exponentials, and quantifiers, it is
also possible to treat negation as a special symbol that only occurs
applied to atomic formulas. Implications are also commonly introduced
into linear logic via definitions: the linear implication \(B \limp
C\) can be defined as \(B^{\bot} \lpar C\), while the intuitionistic
implication \(B \Rightarrow C\) can be defined as \(\bang B \limp
C\). The operators \(\bang\) and \(\quest\) are variously called
modals or exponentials. The term &ldquo;exponential&rdquo; is
particularly appropriate since, following the usual relationship
between exponentiation, addition, and multiplication, linear logic
supports the equivalences \(\bang (B \amp C) \equiv (\bang B \otimes
\bang C)\) and \(\quest(B \oplus C) \equiv (\quest B \lpar \quest C)\),
as well as the 0-ary versions of these equivalences, namely,
\((\bang\top \equiv 1)\) and \((\quest 0 \equiv \bot)\). Here, we use the
binary equivalence \(B \equiv C\) to mean that the formula \((B \limp
C) \amp(C \limp B)\) is derivable in linear logic.</p>

<h3><a name="SeqCal">2.1 Sequent calculus</a></h3>

<p>

A two-sided sequent calculus for linear logic is presented in the
figure below. Notice here that negation is treated as if it were any
other logic connective: that is, its occurrences in formulas are not
restricted and there are introduction rules on the left and right for
negation.  The left and right side of sequents are multiset of
formulas: thus, the order of formulas in these contexts does not
matter but their multiplicity does matter. </p>

<div class="center avoid-break">
<strong>Identity Rules</strong>
\[
\frac{}{B \vdash B}\ \textit{init}
  \qquad
\frac
 {\Delta_1 \vdash B,\Gamma_1 \qquad \Delta_2,B \vdash \Gamma_2}
 {\Delta_1,\Delta_2 \vdash \Gamma_1,\Gamma_2}\ \textit{cut}
\]
</div>

<div class="center avoid-break">
<strong>Negation Rules</strong>
\[
\frac{\Delta \vdash B,\Gamma}{\Delta,B^{\perp} \vdash \Gamma}\ (\cdot)^{\perp} L
   \qquad
\frac{\Delta,B \vdash \Gamma}{\Delta \vdash B^{\perp},\Gamma}\ (\cdot)^{\perp} R
\]
</div>

<div class="center avoid-break">
<strong>Multiplicative Rules</strong>
\[\frac{\Delta \vdash \Gamma}{\Delta,\one \vdash \Gamma}\ \one L
  \qquad
  \frac{}{\vdash \one}\ \one R
\]

\[\frac{}{\bot \vdash}\ \bot L
  \qquad
  \frac{\Delta \vdash \Gamma}{\Delta \vdash \bot,\Gamma}\ \bot R
\]

\[\frac{\Delta, B_1,B_2 \vdash \Gamma}{\Delta, B_1\ot B_2 \vdash \Gamma}\ \ot L
  \qquad
  \frac{\Delta_1 \vdash B,\Gamma_1 \qquad \Delta_2 \vdash C,\Gamma_2}
       {\Delta_1, \Delta_2 \vdash B\ot C,\Gamma_{1},\Gamma_{2}}\ \ot R
\]

\[\frac{\Delta_1,B \vdash \Gamma_1 \qquad \Delta_2, C \vdash \Gamma_2}
       {\Delta_1,\Delta_2, B\lpar C \vdash \Gamma_1,\Gamma_2}\ 
        \lpar L
  \qquad
  \frac{\Delta \vdash B, C,\Gamma}{\Delta \vdash B\lpar C, \Gamma}\ 
  \lpar R
\]
</div>

<div class="center avoid-break">
<strong>Additive Rules</strong>
\[\frac{}{\Delta,\zero \vdash \Gamma}\ \zero L
  \qquad
  \frac{}{\Delta \vdash \top,\Gamma}\ \top R
\]

\[\frac{\Delta, B_i \vdash \Gamma}
       {\Delta, B_1\amp  B_2 \vdash \Gamma}\ {\amp}L\ (i=1,2)
  \qquad
  \frac{\Delta \vdash B,\Gamma \qquad \Delta \vdash C,\Gamma}
       {\Delta \vdash B\amp C,\Gamma}\ {\amp}R
\]

\[\frac{\Delta,B \vdash \Gamma \qquad \Delta,C \vdash \Gamma}
       {\Delta,B\oplus C \vdash \Gamma}\ {\oplus}L
  \qquad
  \frac{\Delta \vdash B_i,\Gamma}
       {\Delta \vdash B_1\oplus B_2,\Gamma}\ {\oplus}R\ (i=1,2)
\]
</div>

<div class="center avoid-break">
<strong>Quantifier Rules</strong>
\[\frac{\Delta, B[t/x] \vdash \Gamma}{\Delta,\forall x.B \vdash \Gamma}\ \forall L
  \qquad
  \frac{\Delta \vdash B[y/x],\Gamma}{\Delta \vdash \forall x.B,\Gamma}\ \forall R
\]

\[\frac{\Delta \vdash B[t/x],\Gamma}{\Delta \vdash \exists x.B\Gamma}\ \exists R
  \qquad
  \frac{\Delta,B[y/x] \vdash \Gamma}{\Delta,\exists x.B \vdash \Gamma}\ \exists L,
\]
</div>

<div class="center avoid-break">
<strong>Exponential Rules</strong>
\[\frac{\Delta \vdash \Gamma}{\Delta, \bang B \vdash \Gamma}\ \bang W
  \quad
  \frac{\Delta, \bang B, \bang B \vdash \Gamma}{\Delta, \bang B \vdash \Gamma}\ \bang C
  \quad
  \frac{\Delta,B \vdash \Gamma}{\Delta, \bang B \vdash \Gamma}\ \bang D
\]

\[\frac{\Delta \vdash \Gamma}{\Delta \vdash \quest B,\Gamma}\ \quest W
  \quad
  \frac{\Delta \vdash \quest B, \quest B,\Gamma}{\Delta \vdash \quest B,\Gamma}\ \quest C
  \quad
  \frac{\Delta \vdash B,\Gamma}{\Delta \vdash \quest B,\Gamma}\ \quest D
\]

\[\frac{\bang\Delta \vdash B,\quest\Gamma}{\bang\Delta \vdash \bang B,\quest\Gamma}\ \bang R
  \quad
  \frac{\bang\Delta,B \vdash \quest\Gamma}{\bang\Delta,\quest B \vdash \quest\Gamma}\ \quest L
\]
</div>

<p>

Notice that the rules of weakening and
contraction are available only for formulas marked with the
exponential \(\bang\) on the left or \(\quest\) on
the right of the sequent. 
The \(\quest\)R and \(\bang\)L rules
are often called &ldquo;dereliction&rdquo; rules.
The \(\quest\)L and \(\bang\)R rules
are often called &ldquo;promotion&rdquo; rules and are the same as the
possibility and necessity rules found in Kripke&rsquo;s S4 modal logic.
The usual proviso for the \(\forall\)-right and
\(\exists\)-left introduction rules are assumed: in particular, the
variable \(y\) must not be free in the formulas of the lower sequent
of those inference rules. Quantification here is assumed to
be first-order: higher-order versions of linear logic can be written
along standard lines.</p>

<p>

The cut rule can be eliminated and completeness is still maintained.
Dually, the <em>init</em> rule can also be eliminated as well except
for the occurrences of <em>init</em> involving atomic formulas.</p>

<h3><a name="FocProSea">2.2 Focused proofs</a></h3>

<p>

An important normal form theorem for the structure of cut-free
proofs was provided by Andreoli
 (<a href="#andreoli92jlc">1992</a>).
He classified a non-atomic formula as <em>asynchronous</em> if its
top-level logical connective is \(\top\), &amp;, \(\bot , \lpar\),
\(\quest\), or \(\forall\) or <em>synchronous</em> if its
top-level logical connective is \(0, \oplus , 1, \otimes\),
\(\bang\), or \(\exists\).</p>

<p>

When viewing proof search as a computational model, we can see
formulas in a sequent as being &ldquo;agents&rdquo; that may act
independently or in concert with others in their environment. Here, the actions
of such agents are determined by reading the introduction rule for them
bottom-up. If an asynchronous formula occurs on the right of a sequent,
it can evolve without affecting provability and without interacting
with its context,
i.e., the corresponding introduction rule is invertible. 
For example, the agent \((B \lpar C)\) becomes (by applying the \(\lpar\)-right introduction rule)
the two agents \(B\) and \(C\) (now working in parallel).
Similarly, the agent \((B \amp C)\) yields (by applying
the &amp;-right introduction rule) two different identical worlds
(sequents) except that \(B\) is in one of these worlds and
\(C\) is in the other.</p>

<p>

On the other hand, if we view a synchronous formula as an agent
whose evolution is determined by the corresponding right-introduction
rule, then it is possible for a provable sequent to evolve to a
non-provable sequent (for example, by applying the \(\oplus\)
right-introduction rule). Also, the instances of such inference rules
depend on details of the context of the formula. For example, the
success of the 1-right introduction rule requires that the surrounding
context is empty and the success of the \(\otimes\)-right
introduction rule depends on how the agent&rsquo;s surrounding context is
divided into two contexts. Thus, the evolution of such agents
depends on &ldquo;synchronizing&rdquo; with other parts of the
context.</p>

<p>

Now consider a one-sided sequent calculus presentation of linear
logic where the only introduction rules are right-introduction rules.
Given the above classification of connectives, it is possible to show
that proof search can be structured into the following phases without
loss of completeness. The <em>asynchronous phase</em> occurs if there
is an asynchronous formula present in the sequent. In this phase,
right-introduction rules are applied in any order until there are no
further asynchronous formulas. In the <em>synchronous phase</em> some
synchronous formula is selected and becomes the &ldquo;focus&rdquo; of
this phase: that is, right-introduction rules are applied to it and to
any synchronous subformula that it might generate.</p>

<p>

The following figure illustrates the focusing proof system linear
logic. Notice that the two phases are represented by different arrows:
the up-arrow denotes the asynchronous phase and the down-arrow denotes
the synchronous phase. Also, sequents are divided into three <em>zones</em>
(where the zones are separated by either a semicolon or an up or down-arrow).
In particular, to the left of the up-arrow and down-arrow are the two zones.
The zone written as \(\Psi\) denotes a set of
formulas that can be used any number of times in the proof of that sequent.
The zone written as \(\Delta\) denotes a multiset of formulas
that are restricted as in MALL.
The zone to the right of an up-arrow is also a multiset of
formulas while the zone to the right of a down-arrow is a single formula.
It is
possible to impose an arbitrary order on the formulas to the right of
the up-arrow since the introduction of asynchronous formulas can be
done in any order. 
Atoms are given polarity and in the figure below,
\(A\) stands for positive atoms and the negation of \(A\) stands 
for negative atoms.
Proofs built by these inference rules are called
<em>focused</em> proofs. The result in
 <a href="#andreoli92jlc">Andreoli 1992</a>
 is that focused proofs are complete for linear logic.</p>

<div class="center avoid-break">
<strong>Asynchronous Phase</strong>
\[\frac{\Up{\Psi}{\Delta}{L}}{\Up{\Psi}{\Delta}{\bot,L}}\ [\bot]
     \qquad
\frac{\Up{\Psi,F}{\Delta}{L}}
     {\Up{\Psi}{\Delta}{\quest F,L}}\ [\quest]
\]

\[\frac{}
       {\Up{\Psi}{\Delta}{\top,L}}\ [\top]
  \qquad
\frac{\Up{\Psi}{\Delta}{F[y/x],L}} 
     {\Up{\Psi}{\Delta}{\forall x.F,L}}\ [\forall]
\]

\[\frac{\Up{\Psi}{\Delta}{F_1,F_2,L}}
     {\Up{\Psi}{\Delta}{F_1\lpar F_2,L}}\ [\lpar]
  \qquad
\frac{\Up{\Psi}{\Delta}{F_1,L}\quad \Up{\Psi}{\Delta}{F_2,L}}
     {\Up{\Psi}{\Delta}{F_1\amp F_2,L}}\ [\amp]
\]


\[\frac{\Up{\Psi}{\Delta,F}{L}}{\Up{\Psi}{\Delta}{F,L}}
   \ [R\Uparrow]\ \text{provided that $F$ is not asynchronous}
\]
</div>

<div class="center avoid-break">
<strong>Synchronous Phase</strong>
\[\frac{}{\Down{\Psi}{\cdot}{\one}}\ [\one]
  \qquad
  \frac{\Down{\Psi}{\Delta_1}{F_1}\quad \Down{\Psi}{\Delta_2}{F_2}}
       {\Down{\Psi}{\Delta_1,\Delta_2}{F_1\ot F_2}}
   \ [\ot]
\qquad
\frac{\Up{\Psi}{\cdot}{F}}{\Down{\Psi}{\cdot}{\bang F}}
  \ [\bang]
\]

\[\frac{\Down{\Psi}{\Delta}{F_i}}{\Down{\Psi}{\Delta}{F_1\oplus F_2}}
  \ [\oplus_i]
  \qquad
\frac{\Down{\Psi}{\Delta}{F[t/x]}}
  {\Down{\Psi}{\Delta}{\exists x.F}}
   \ [\exists]
\]

\[\frac{\Up{\Psi}{\Delta}{F}}{\Down{\Psi}{\Delta}{F}}
   \ [R\Downarrow]\ \text{provided that $F$ is either asynchronous or an atom} 
\]
</div>

<div class="center avoid-break">
<strong>Identity and Decide Rules</strong>
\[\frac{}{\Down{\Psi}{A}{A^{\perp}}}
   \ [I_1]
\qquad
  \frac{}{\Down{\Psi,A}{\cdot}{A^{\perp}}}
     \ [I_2]\ \text{where } A \text{ is an atom}
\]

\[\frac{\Down{\Psi}{\Delta}{F}}{\Up{\Psi}{\Delta,F}{\cdot}}
   \ [D_1]
\qquad
   \frac{\Down{\Psi}{\Delta}{F}}{\Up{\Psi,F}{\Delta}{\cdot}}
   \ [D_2]\ \text{where } F \text{ is a positive formula}
\]
</div>

<p>

Focused proof systems have also been designed for classical and intuitionistic
logics (<a href="#danos97jsl">Danos <em>et al</em>. 1997</a>; 
<a href="#laurent05apal">Laurent <em>et al</em>. 2005</a>; 
<a href="#liang09tcs">Liang &amp; Miller 2009</a>).</p>

<h3><a name="ProNet">2.3 Proof nets</a></h3>

<p>

Proofs presented using sequent calculus contain a lot of detail that
sometimes is uninteresting: consider for example how many
uninterestingly different ways there are to form a proof of \(\vdash \Gamma , (A_1\lpar A_2),
\ldots ,(A_{n-1}\lpar A_n)\) from a derivation of \(\vdash \Gamma ,
A_1, A_2 , \ldots ,A_n\). This unpleasant fact derives from the
sequential nature of proofs in sequent calculus: if we want to apply a
set \(S\) of \(n\) rules to different parts of a sequent, we
cannot apply them in one step, even if they do not interfere with each
other! We must <em>sequentialize</em> them,
i.e., choose a linear order on \(S\) and apply the rules in
\(n\) steps, according to this order.</p>

<p>

A natural question arises: &ldquo;Is there a representation of
proofs that abstracts from such uninteresting details?&rdquo;. A
similar question is answered positively in the case of intuitionistic
sequent calculus by means of what is known as <em>natural
deduction</em>, that has, via the Curry-Howard correspondence, a strong
connection with the computational device known as \(\lambda\)-calculus.</p>

<p>

For linear logic, this succinct representation of proofs is given by
<em>proof nets</em>, graph-like structures that enjoy particularly
good properties for the MLL fragment of the logic. The first step
towards this representation is to convert all the sequent calculus
system, using the involutivity of negation, into a one-sided system,
where sequents are of the form \(\vdash \Gamma\). As a consequence, the
number of rules is reduced since we have no left-introduction rules,
but we keep the same expressive power, as provability stays the
same.</p>

<p>

To each sequent calculus proof in MLL, one can
inductively associate a proof net with the same <em>conclusions</em>
as follows:</p>

<ul>
<li>To a proof reduced to the axiom rule, we associate an <em>axiom
link</em>. 

<blockquote>
 <img src="Axiom.jpg" alt="Axiom net" />
</blockquote>
</li>

<li>For a proof obtained by applying the cut rule to two proofs,
we first inductively build the proof nets associated to those two proofs,
and then we combine them using a <em>cut link</em>.

<blockquote>
 <img src="Cut.jpg" alt="Cut net construction" />
</blockquote>
</li>

<li>For a proof obtained by applying the tensor rule to two proofs, we
first inductively build the proof nets associated to those two proofs,
and then we combine them using a <em>tensor link</em>.

<blockquote>
 <img src="Tensor.jpg" alt="Tensor net construction" />
</blockquote>
</li>

<li>For a proof obtained by applying the par rule to a proof, first
inductively build the proof net associated to that proof, and then we
add a &ldquo;par link&rdquo;.

<blockquote>
 <img src="Par.jpg" alt="Par net construction" />
</blockquote>
</li>
</ul>

<p>

All this can be properly formalized using hypergraphs (formulas are
nodes and &ldquo;links&rdquo; are oriented hyperedges with hypotheses
and conclusions), and we can formally define as a proof net a
hypergraph inductively built out of a sequent calculus derivation of
MLL. Notice that there are quite a lot of hypergraphs that are not
proof nets.</p>

<p>

Now if you look at the proof net built from the derivations of \(\vdash \Gamma , (A_1\lpar A_2),
\ldots ,(A_{n-1}\lpar A_n)\) obtained from \(\vdash \Gamma ,
A_1, A_2 , \ldots ,A_n\), you will see that all trace of the
order of application of the rules has disappeared. In a sense, the
proof nets are an equivalence class of sequent calculus derivations
with respect to the derivation order of rules whose application
commute.</p>

<p>

Suppose that somebody now comes to you with a huge hypergraph built
with axiom, cut, par and tensor links, pretending that it is actually a
representation of the proof of some long-standing open mathematical
problem. How can you verify that it is actually a representation
of a proof, and not just a random structure?</p>

<p>

Performing this <em>correctness</em> check is a challenge that amounts
to rebuilding a sequential construction history for your structure,
corresponding to a derivation in sequent calculus, and seems at first
a very complex problem: the first correctness criterion for MLL proof
nets, called the &ldquo;long trip criterion&rdquo;, and present in
Girard&rsquo;s original paper, is exponential, as well as the ACC (Acyclic
connected) criterion of Danos and Regnier (<a href="#danos89aml">1989</a>) 
found later on.
Nevertheless, there exists a much more efficient criterion, known as
Contractibility, due to Danos and Regnier, that has more recently been
reformulated as the following elegant graph parsing criterion by
Guerrini, Martini and Masini: a hypergraph is a proof net if and only
if it reduces to the singleton node &ldquo;net&rdquo; via the
following graph reduction rules</p>

<p>
 <img src="parsing.jpg" alt="Graph Parsing for MLL proof net recognition" />
</p>

<p>

Performing this check naively can take quadratic time (each
application of a rule may require an entire lookup of the graph to
find the redex, and we need to perform as many steps as there are
hyperlinks in the graph).
Linear time algorithms have been give by Guerrini (<a href="#guerrini11tcs">2011</a>) 
and by Murawski and Ong (<a href="#murawski06tocl">2006</a>).</p>

<p>
Another style of correctness criterion for MLL proof nets is given by 
Retor&eacute; <a href="#retore03tcs">(2003)</a> in which a quadratic
algorithm is given for MLL.
</p>

<p>

On proof nets, one can perform cut elimination in a particularly clean
way: due to their parallel nature, cuts can be eliminated locally via
two simplification rules:</p>

<ul>
<li>Axiom move: 

<blockquote>
 <img src="Identity.jpg" alt="Axiom move" />
</blockquote>
</li>

<li>Multiplicative move: 

<blockquote>
 <img src="Multiplicative.jpg" alt="Multiplicative move" />
</blockquote>
</li>
</ul>

<p>

These are actually computation rules over proof nets, and the
correctness criteria allow to verify easily that any such rule
preserves correctness, and as a consequence, the reduction of a proof net
still comes from a sequent calculus proof of the same sequent.</p>

<p>

Hence, cut elimination in MLL proof nets can be performed in linear
time and gives a simple, elegant cut-elimination result for all of
MLL.</p>

<p>

The proof nets approach can be extended to larger subsets of linear
logic, but then it is less clear how to obtain the same elegant results
as for MLL: the original system proposed in
 <a href="#girard87tcs">Girard 1987</a>
 works for MELL, for example, by associating to the four exponential
rules the following hypergraph constructions:</p>

<ul>
<li>Contraction 

<blockquote>
 <img src="Contraction.jpg" alt="Contraction construction" />
</blockquote>
</li>

<li>Weakening 

<blockquote>
 <img src="Weakening.jpg" alt="Weakening construction" />
</blockquote>
</li>

<li>Dereliction 

<blockquote>
 <img src="Dereliction.jpg" alt="Dereliction construction" />
</blockquote>
</li>

<li>Promotion, that introduces the notion of &ldquo;box&rdquo;, a
sequentialization mark around a piece of a proof net materialized in
the pictures of the graphs by the rectangle drawn around the proof net
of conclusions \(A\) and \(\quest\Gamma\). 

<blockquote>
 <img src="Promotion.jpg" alt="Promotion construction" />
</blockquote>
</li>
</ul>

<p>

While these constructions and the associated graph reductions bear
striking similarity with \(\lambda\)-calculus with explicit substitutions,
as first remarked by Di Cosmo &amp; Kesner
 (<a href="#dicosmo97lics">1997</a>),
 they are too similar to the corresponding sequent calculus rules: the
parallelization effect so elegant for MLL does not properly carry on
here, and the graph reduction rules involve boxes and are not
local.</p>

<p>

To recover a satisfactory system, many proposals have been made,
starting from the one by Danos &amp; Regnier
 (<a href="#danos95all">1995</a>)
 but we want to mention here the very elegant
approach by Guerrini, Martini and Masini
 (<a href="#guerrini03tcs">Guerrini <em>et al.</em> 2003</a>),
 that neatly shows the connection between two level proof systems for
modal logic, proper proof nets for MELL, and optimal reduction in the
\(\lambda\)-calculus.</p>

<p>
A recent paper by Heijltjes and Houston <a href="#heijltjes16lmcs">(2016)</a>
has shown that there can be no satisfactory notion of proof nets for MLL if 
units are also allowed. 
</p>

<p>
It is possible to provide a canonical treatment of additive
connectives, even with first-order quantification 
<a href="#heijltjes18tr">(Heijltjes <em>et al</em>. 2018)</a>. 
Proof nets for formulas containing both multiplicative and
additive connectives have various technical presentations, none of
which appears canonical and satisfactory. Their treatment in
proof-net-like proof systems is currently a topic of active research.
In particular, see <a href="#hughes05tocl">(Hughes and van Glabbeek 2005)</a> and 
<a href="#hughes16lics">(Hughes and Heijltjes 2016)</a>.
</p>

<h2><a name="Sem">3. Semantics</a></h2>

<p>

Approaching the semantics of linear logic is usually done along two
different paths. First, there are various semantic structures
available that can be used to map formulas to denotations in such
structures. That approach can be used to establish soundness and
completeness for various fragments of linear logic. A more novel
semantic approach to linear logic involves giving semantics to proofs
directly. We describe briefly these two approaches and provide some
links to the literature.</p>

<h3><a name="SemProv">3.1 Semantics of provability</a></h3> 

<p>

One approach to attempting a sound and complete semantics for
fragments of linear logic associates to a formula the set of all
contexts that can be used to prove that formula. Of course, such a
collection may need to be more abstract and to be given various
closure properties. The <em>phase semantics</em> of Girard
 (<a href="#girard87tcs">1987</a>)
 provides one such semantics: some uses of such semantics have been
made in computer science to provide counterexamples and as a tool that
can help establish that a given concurrent system cannot evolve into
another with certain properties
 (<a href="#fages01ic">Fages <em>et al</em>. 2001</a>).
 Similarly,
Kripke-style semantics have been provided in
 <a href="#allwein93jsl">Allwein &amp; Dunn 1993</a>
 and
 <a href="#hodas94ic">Hodas &amp; Miller 1994</a>.
 Quantales, certain kind of partially ordered algebraic structures,
have also been used to provide early semantic models for parts of
linear logic
 (<a href="#yetter90jsl">Yetter 1990</a>).</p>

<h3><a name="SemProo">3.2 Semantics of proofs</a></h3> 

<p>

In the formulas-as-types analogy which is so popular and fruitful in
theoretical computer science, a logical system is put in
correspondence with a typed computational device (like typed \(\lambda\)-calculus), 
by associating to each proof of that formula a program having
that formula as a type. For example, a proof of the tautology
\(A \Rightarrow A\) corresponds to the program
<em>fun</em>\((x:A).x:A\rightarrow A\),
the identity function on objects of type \(A\). This is why, in
constructive logical systems (such as intuitionistic logic and arithmetic),
and in linear logic, so much importance
is attached to proofs, to the point that building and studying models
of proofs gets so much more attention than building and studying
models of provability: we are not satisfied to know that a formula is
provable, we really want to know the <em>computational content</em> of
its proof.</p>

<p>

Many models of linear logic proofs have been proposed; we consider
that, to date, the simplest and most intuitive construction is those
based on the so-called &ldquo;relational semantics&rdquo; or
&ldquo;Kripke-style semantics&rdquo;, where formulas are interpreted
as multisets, one-sided sequents are interpreted as tuples of
multisets, and proofs are interpreted as relations over the
interpretation of sequents. If one wants to give a purely
set-theoretic semantics, without resorting to multisets, it is
possible to do it by means of coherence spaces, sets equipped with a
special coherence relation, as originally shown by in
 <a href="#girard87tcs">Girard 1987</a>.
 There are interesting
category theoretical models of linear logic, such as the *-autonomous
categories
 (<a href="#barr91mscs">Barr 1991</a>)
 and hypercoherences
 (<a href="#ehrhard93mscs">Ehrhard 1993</a>).</p>

<p>

Another approach to the semantics of proofs is given by Girard&rsquo;s
<em>Geometry of Interaction</em>, that allows us to obtain a fully
algebraic characterization of proofs. To each proof net, one can
associate a partial permutation matrix \(\sigma\) corresponding to the
cut links, and a proper matrix \(M\) corresponding expressions built out of a 
certain
dynamic algebra, that describe the possible paths inside the proof
net. It is then possible to fully describe the proof net via the
<em>execution formula</em></p>

\[
\mathrm{EX}(\sigma ,M) = (1-\sigma^2) \left(\sum_i M(\sigma M)\right) (1-\sigma^2)
\]

<p>

which, in the MLL case, is an invariant of the normalization
process. Some nice connection to results coming from data-flow theory
has been shown in some early work of Abramsky &amp; Jagadeesan
 (<a href="#abramsky94ic">1994</a>).</p>

<p>
The area of semantics that has developed around so-called <em>game
semantics</em> deserves special attention. The strong connection between
games and linear logic was pointed out quite early by A. Blass 
(<a href="#blass92apal">1992</a>).
In fact, there are two different traditions to connecting logic
to games. In the tradition of <em>dialog games</em> dating back to
Lorenzen, one player attempts to prove a formula while a second player
attempts to refute it. It is possible to provide MALL with such a
dialog game that is completely symmetric for both the prover and the
refuter (<a href="#delande10apal">Delande <em>et al</em>. 2010</a>).
In another tradition, formulas are
interpreted as games, logical connectives as game constructors, and
proofs as strategies that describe how a player reacts to opponent
moves. By imposing different restrictions on the rules of the game,
one can actually provide a precise semantics (technically, a
fully abstract model) for various features of actual programming
languages, hence the huge interest in this area over the past
years. See, for example, 
 <a href="#abramsky94ic">Abramsky &amp; Jagadeesan 1994</a>,
 <a href="#abramsky99lics">Abramsky &amp; Melli&egrave;s 1999</a>,
 and
 <a href="#hyland00ic">Hyland &amp; Ong 2000</a>.
</p>

<h2><a name="Com">4. Complexity</a></h2>

<p>
For any given logic, it is useful to know whether or not there is an
effective procedure to determine, for each sentence in the logic, if
it is provable or not. A <em>decidable</em> logic&mdash;i.e., one for
which there is an effective procedure for provability&mdash;is often
described by its
<em>complexity class</em>, which characterizes how difficult it is
to perform the decision procedure.
Extensive research work has been dedicated to the study of the
complexity and decidability issues for several fragments of
propositional linear logic. It is known that</p>

<ul>
<li>MLL provability is NP-complete
 (<a href="#kanovich92">Kanovich 1992</a>),</li>

<li>MALL provability is PSPACE-complete
 (<a href="#lincoln92">Lincoln <em>et al</em>. 1992</a>),</li>

<li>LL provability is undecidable
 (<a href="#lincoln92un">Lincoln <em>et al</em>. 1992</a>, 
 <a href="#lincoln95all">Lincoln 1995</a>), and that</li>

</ul>

<p>
NP, PSPACE, and EXPSPACE are complexity classes such that NP \(\subseteq\)
PSPACE \(\subseteq\) EXPSPACE. Surprisingly, for those that may forget that
the novelty in linear logic lies in the way formulas are managed
without the structural rules of contraction and weakening, 
these results stay the same even if we focus
on the fragments of the logics where only the constants, and no
propositional variables, are allowed (<a href="#kanovich94trb">Kanovich 1994</a>,
 <a href="#lincoln92un">Lincoln &amp; Winkler 1994</a>). Indeed, it is
possible to encode arbitrary formulas into constant-only formulas
preserving provability.</p>

<p>
MELL is a surprisingly expressive logic. For example, the
reachability problem in Petri nets can be encoded into MELL <a
href="#gunter89atpn">(Gunter &amp; Gehlot 1989)</a> and that problem is
equivalent to the reachability problem of vector addition systems with
states (VASS) <a href="#reutenauer89">(Reutenauer 1989)</a>.
Furthermore, the decidability problem of MELL is equivalent to the
reachability problem for branching VASS <a href="#degroote04lics">(de
Groote <em>et al</em>. 2004)</a> and the latter is known to have a
non-elementary lower bound <a href="#lazic15tocl">(Lazic and Schmitz
2015)</a>. Thus, if MELL turns out to be decidable it will be at
least TOWER-hard <a href="#lazic15tocl">(Lazic and Schmitz 2015)</a>.
A proof of the decidability of MELL has been given by Bimb&oacute;
<a href="#bimbo15">(2015)</a> but a gap in that proof 
has been reported in Stra&szlig;burger <a href="#strassburger18tr">(forthcoming)</a>.
</p>

<p>
Linear logic with the unrestricted weakening rule added 
(also known as <em>linear affine logic</em>) is decidable
(<a href="#kopylov95lics">Kopylov 1995</a>) and to be exponential 
space hard (<a href="#urquhart00lc">Urquhart 2000</a>).
</p>

<p>
A good overview of complexity results surrounding linear logic can
be found in
 <a href="#lincoln95all">Lincoln 1995</a>.</p>

<h2><a name="ComSciImp">5. Computer science impact</a></h2>

<p>

When intuitionistic logic was first proposed early in the last
century, it was presented as a challenge to the way traditional
mathematicians were supposed to do business. Uses of the excluded middle
and of proof-by-contradiction were considered suspect and problematic,
particularly in the presence of infinity. As intuitionistic logic
concerns were developed into constructive mathematics, new constructive
approaches have arisen to topics such as topology, algebra, and
analysis. Given that linear logic encompasses the dynamics of proof
(algorithm) and resources, its primary impacts has been not in
traditional mathematics but in computer science. Before overviewing the
nature of that impact, we outline the various ways in which logic more
generally is used in computer science.</p>

<p>

Logic plays different roles in the specification of computations. We
can identify the following broad different approaches and note which
roles have felt influences from linear logic.</p>

<p>

In the <em>computation-as-model</em> approach, computations are
encoded as mathematical structures and consist of such items as nodes,
transitions, and states. Logic is used in an external sense to make
statements <em>about</em> those structures. That is, computations are
used as models for logical expressions. Intensional operators, such as
the modals of temporal and dynamic logics or the triples of Hoare
logic, are often employed to express propositions about the change in
state. This use of logic to represent and reason about computation is
probably the oldest and most broadly successful use of logic for
representing computation. This role for logic has felt little influence
from linear logic.</p>

<p>

In the <em>computation-as-deduction</em> approach, pieces of logic&rsquo;s
syntax (such as formulas, terms, types, and proofs) are used directly
as elements of the specified computation. In this more rarefied
setting, there are two rather different approaches to how computation
is modeled, called the <em>proof normalization</em> approach and the
<em>proof search</em> approach.</p>

<p>

We outline below the significant impacts that linear logic has had on
both of these different settings.</p>

<h3><a name="ProNor">5.1 Proof normalization</a></h3>

<p>

The <em>proof normalization</em> approach views the state of a
computation as a proof term and the process of computing as
normalization (known alternatively as \(\beta\)-reduction or cut-elimination).
Functional programming can be explained using proof-normalization as
its theoretical basis
 (<a href="#martinlof82lmps">Martin-L&ouml;f 1982</a>)
 and has been used to justify the design of new functional
 programming languages, e.g.,
 <a href="#abramsky93tcs">Abramsky 1993</a>.
 Linear logic provides this approach to computational specification
with new types, new declarative means for statically understanding how
resources may be used in a computation, and provided an appealing
means for formalizing the duality between a function and the
environment that supplies it with arguments.</p>

<p>

Another area where linear logic has been a powerful theoretical
instrument is that of <em>optimal reduction</em>. The problem of
building efficient (optimal) interpreters for the \(\lambda\)-calculus, that
stayed open for quite a long time after its original definition by J.J.
L&eacute;vy, was solved for the first time in 
 <a href="#lamp90">Lamping 1990</a>, 
 via a sophisticated sharing graph implementation involving a quite
impressive amount of rules. Using ideas and intuition from linear
logic, many authors reconstructed Lamping&rsquo;s solution, simplifying it
and leading to a rich theory connected to that of the Geometry of
Interaction. For further reading, a good reference
is <a href="#asperti98cup">Asperti &amp; Guerrini 1998</a>.
</p>

<p>

The refinement of intuitionistic logic provided by linear logic and
the dualities of linear logic provided a setting in which one could
view a function and its environment as similar entities that interact
dually. For example, a function with the type \(A \limp B\) can be
modeled as a process that consumes a value of type \(A\) from its
environment and transforms it into a value of type \(B\). In linear
logic, this implication is equivalent to its contrapositive form: the
type \(B^{\bot} \limp A^{\bot}\) can lead to interpreting the same
function as a process that transforms a demand for a value of type
\(B\) into a demand for a value of type \(A\) (notice that this does
not happen with functions of intuitionistic type since, for example,
input argument may be vacuous)
 (<a href="#curien03bsl">Curien 2003</a>).
 The recent successes of using game semantics to model functional
computation are similarly related to the dual treatment of function
and environment (<a href="#abramsky94ic">Abramsky and Jagadeesan 1994</a>,
 <a href="#hyland00ic">Hyland &amp; Ong 2000</a>).</p>

<p>

Finally, we mention that in the area of encoding computation as proof
normalization, linear logic has been used to provide a type-based
description of polytime recursive functions. For example, M.
 Hofmann
 (<a href="#hofmann03ic">2003</a>)
 introduced a \(\lambda\)-calculus with
modal and linear types that extended the function algebra of
 <a href="#bellantoni92cc">Bellantoni &amp; Cook 1992</a>
 to higher types. Types based on linear logic have also been used
within functional programs: see
 <a href="#guzman90lics">Guzman &amp; Hudak 1990</a>
 and
 <a href="#wadler91pepm">Wadler 1991</a>.</p>

<h3><a name="ProSea">5.2 Proof search</a></h3>

<p>

The <em>proof search</em> approach views the state of a computation
as a sequent (a structured collection of formulas) and the process of
computing as the process of searching for a proof of a sequent: the
changes that take place in sequents capture the dynamics of
computation. 
With this view of computation, we generally read
inference rules bottom up, i.e., 
as a transformation of their conclusion into their premise(s). 
Logic programming can be explained using proof search as
its theoretical basis, and linear logic provides this approach to
computational specification with new combinators for building logic
programs, new means to capture rich dynamics, and new
declarative approaches to specifying concurrent computations. (See
 <a href="#miller04llcs">Miller 2004</a>
 for an overview of linear logic programming languages.)</p>

<p>

The completeness of focusing proof system can be used to provide a
declarative explanation of part of the operational semantics of logic
programming within linear logic. Consider, for example, the subset
\(L\) of formulas of linear logic that are built from only the
connectives \(\top\), &amp;, \(\limp , \Rightarrow\), and \(\forall\). (Notice
that if one adds \(\bot\) to this list, it is possible to encode all
connectives of linear logic.) It is possible to see that cut-free
proof search in \(L\) can be defined into to phases. Given a
sequent \(\Gamma\); \(\Delta \rightarrow G\), where \(\Gamma\) is a set of
formulas (which can be contracted and weakened), \(\Delta\) is multiset
of formulas (which cannot be contracted nor weakened), and \(G\)
(the &ldquo;goal&rdquo; formula) is a single formula (all
from \(L)\), then proof search proceeds as follows.</p>

<ol> 

<li>If \(G\) is non-atomic, then only a right introduction rule
can be used to conclude this sequent. Given this set of connectives,
the right rules are invertible and this <em>goal-reduction</em> phase
corresponds exactly to the asynchronous phase of focused proofs.</li>

<li>If \(G\) is atomic, then proof search proceeds by
<em>deciding</em> on a single formula from a left-hand context.</li>

<li>Once a formula is chosen for the <em>focus</em>, all
left-introduction rules are applied to only that formula and any
positive subformulas that arise. This <em>backchaining</em> phase
corresponds to the asynchronous phase of focused proof
construction.</li>
</ol>

<p>

Formally, these various phases can be described using the following
inference rules. Here, a new sequent arrow is introduced:
this arrow is labeled with the formula that is the result of a
left-introduction rule. Notice that the rule for left-introduction of
\(\limp\) requires splitting the \(\Delta\) context
into two parts \(\Delta_1,\Delta_2\) (when reading
the rule bottom up). There are, of course, \(2^n\) such
splittings if that context has \(n \ge 0\) distinct
formulas.
The syntactic variable \(A\) in these inference rules ranges over
atomic formulas.</p>

<div class="center avoid-break">
<strong>Goal Reduction Phase</strong>
\[
\frac{}  
     {\Gamma;\Delta \vdash \top}\ \top R
  \qquad

\frac{\Gamma;\Delta \vdash B \qquad \Gamma;\Delta \vdash C}
     {\Gamma;\Delta \vdash B \amp C}\ {\amp}R
\]

\[\frac{\Gamma;\Delta, B \vdash C}
       {\Gamma;\Delta \vdash B \limp C}\ \limp R
  \qquad

\frac{\Gamma,B ;\Delta \vdash C}
     {\Gamma;\Delta \vdash B \Rightarrow C}\ {\Rightarrow}R
  \qquad

\frac{\Gamma;\Delta \vdash B[y/x]}
     {\Gamma;\Delta \vdash \forall x. B}\ \forall R
\]
</div>

<div class="center avoid-break">
<strong>Backchaining Phase</strong>
\[
\frac{\Gamma;\Delta \lvdash{D_1} A}
     {\Gamma;\Delta \lvdash{D_1\amp D_2}\, A} \ {\amp}L
  \qquad

\frac{\Gamma;\Delta \lvdash{D_2} A}
     {\Gamma;\Delta \lvdash{D_1\amp D_2} A}\ {\amp}L
  \qquad

\frac{\Gamma;\Delta \lvdash{D[t/x]} A}
     {\Gamma;\Delta \lvdash{\forall_{\tau}x.D} A}\ \forall L
\]

\[\frac{\Gamma;\Delta_1 \vdash G \quad \Gamma;\Delta_2 \lvdash{D} A}
       {\Gamma;\Delta_1,\Delta_2 \lvdash{G\limp D} A} \ {\limp}L
  \qquad

\frac{\Gamma;\cdot \vdash G \quad \Gamma;\Delta \lvdash{D} A}
     {\Gamma;\Delta \lvdash{G\Rightarrow D} A}\ {\Rightarrow}L
\]
</div>

<div class="center avoid-break">
<strong>Identity and Decide Rules</strong>
\[
\frac{\Gamma,D;\Delta \lvdash{D} A}
     {\Gamma,D;\Delta \vdash A}\ \textit{decide}{!}
  \qquad

\frac{\Gamma;\Delta \lvdash{D} A}
     {\Gamma;\Delta,D \vdash A}\ \textit{decide}
  \qquad

\frac{}
     {\Gamma;\cdot \lvdash{A} A}\ \textit{init}
\]
</div>

<p>

Linear logic restricted to \(L\) can be viewed as a linear logic
programming language. As a consequence, it can serve as a
specification language for computational systems, a role that is also
occupied by, say, Petri nets, process calculi, \(\lambda\)-calculus,
etc. Given that linear logic has a proof theory and various kinds of
semantics, broad avenues of reasoning about computations specified in
\(L\) are provided by the meta-theory of linear logic.</p>

<p>

Given that the sequent calculus for linear logic uses multisets of formulas,
proof search can directly encode <em>multiset rewriting</em>. Since
many computations can naturally be seen as multiset rewriting, it has
been possible to make numerous connections between linear logic and
Petri nets
 (<a href="#gunter89atpn">Gunter &amp; Gehlot 1989</a>),
 process calculi
 (<a href="#andreoli91ngc">Andreoli &amp; Pareschi 1991</a>,
 <a href="#kobayashi99tcs">Kobayashi <em>et al</em>. 1999</a>,
 <a href="#miller96tcs">Miller 1996</a>),
 and security protocols
 (<a href="#cervesato99csfw">Cervesato <em>et al</em>. 1999</a>,
 <a href="#miller03fcs">Miller 2003</a>).</p>

<h2><a name="Var">6. Variations</a></h2>

<h3><a name="DifTreMod">6.1 Different treatments of modality</a></h3>

<p>

The exponentials \(\bang\) and \(\quest\) in linear
logic are less carved in the marble than the other
connectives. Indeed, if one uses traditional sequent calculus
presentations, the exponentials are not canonical in the following sense: if
you introduce another copy of exponentials, say
\(\bang'\) and \(\quest'\), with the same
rules as the original ones, there is no way to prove that
\(\bang\) is equivalent to \(\bang'\), and
\(\quest\) to \(\quest'\), while for the other
connectives this is easily established. 
Various applications of non-canonical exponentials can be
found in (<a href="#danos93kgc">Danos et. al., 1993</a>; 
<a href="#nigam09ppdp">Nigam &amp; Miller, 2009</a>). 
Although the decidability of MELL is currently being debated 
(<a href="#bimbo15">Bimb&oacute; 2015</a>,
<a href="#strassburger18tr">Stra&szlig;burger forthcoming</a>), 
extending MLL with three pairs of \(\bang\) and
\(\quest\) yields a logic that is undecidable
 <a href="#chaudhuri18mscs">(Chaudhuri 2018)</a>. 
Martini and 
Masini <a href="#martini95all">1995</a> describe a &ldquo;2-sequent&rdquo; 
proof system in which the exponentials are canonical.</p>

<p>
The fact that cut-elimination can make proofs in classical and
intuitionistic logic grow to enormous size can be analyzed in terms of the
application of the contraction rule in those proof systems. If proof systems
introduce restrictions on contraction, it is possible to design new
logics and proof systems for which cut-elimination has a much-reduced
complexity. For example, <em>elementary linear logic</em> (ELL) is
obtained by replacing the \(\bang\) and \(\quest\)
introduction by a single rule introducing \(\bang\) and
\(\quest\) at the same time. As a consequence, ELL can encode
all and only the Kalmar elementary functions (computable in time
bounded by a tower of exponentials of fixed height) 
(<a href="#girard98ic">Girard 1998</a>, 
<a href="#baillot15ic">Baillot 2015</a>). Still, other variations on the inference rules for the
exponentials have been studied. For example, <em>light linear
logic</em> (<a href="#girard98ic">Girard 1998</a>) and <em>soft linear
logic</em> (<a href="#lafont04tcs">Lafont 2004</a>) both characterize
functions computable in polynomial time: see also
 (<a href="#baillot04lics">Baillot &amp; Terui 2004</a>).
</p>

<h3><a name="NonComLinLog">6.2 Non-commutative linear logic</a></h3>

<p>

While linear logic rejects the universal application of the two
structural rules of weakening and contraction, it allows the
unrestricted use of the structural rule called <em>exchange</em>. A sequent
calculus that does not universally employ the exchange rule has
sequents whose left and right contexts are lists: the order of formulas
within context becomes an expressive element of the logic. In this
case, the multiplicative disjunction and conjunction can become
non-commutative.</p>

<p>

One of the first logics that rejects all three structural rules of
the sequent calculus was given in 
 <a href="#lambek58amm">Lambek 1958</a>.
 While this logic contains <em>two</em> implications, it does not
contain a negation nor exponentials. Various recent papers have
proposed extending linear logic to include non-commutative features
and, at present, no proposal seems canonical. For a sampling of
non-commutative linear logics, see
 <a href="#yetter90jsl">Yetter 1990</a>,
 <a href="#abrusci91jsl">Abrusci 1991</a>,
 <a href="#retore97tlca">Retor&eacute; 1997</a>,
 <a href="#abrusci99apal">Abrusci &amp; Ruet 1999</a>, and
 <a href="#guglielmi01csl">Guglielmi &amp; Stra&szlig;burger 2001</a>.</p>

<h3><a name="unbounded">6.3 Treatment of unbounded behavior</a></h3>

<p>
While the MALL logic is an expressive and novel logic, it is also
decidable and, thus, not capable of capturing the unbounded behaviors 
found in, say, mathematics and computer science. As described above, 
the addition of the exponentials ! and ? enriches MALL to full linear 
logic and to a setting where unbounded behaviors can be captured. 
A second approach to extending MALL to capture unbounded behaviors 
involves the addition of
the least and greatest fixed point operators as logical connectives 
directly into MALL. In order to properly characterize fixed points 
as being either the least
or the greatest, it is necessary for the inference rules for fixed
points to be
&ldquo;higher-order&rdquo; in 
the sense that they involve invariants. Such an extension to MALL 
(also with first-order
quantification and term equality) has been developed by Baelde 
(<a href="#baelde07lpar">Baelde &amp; Miller, 
2007</a>; 
<a href="#baelde12tocl">Baelde 2012</a>) and has been used to 
provide a proof-theoretic foundation for model checking 
(<a href="#heath18jar">Heath &amp; Miller 2018</a>).
</p>

</div>

<div id="bibliography">

<h2><a name="Bib">Bibliography</a></h2>

<ul class="hanging">

<li><a name="abramsky93tcs"></a>Abramsky, S., 1993, &ldquo;Computational
interpretations of linear logic&rdquo;, <em>Theoretical Computer
Science</em>, 111: 3&ndash;57.</li>

<li><a name="abramsky94ic"></a>Abramsky, S., and Jagadeesan, R., 1994,
&ldquo;New Foundations for the Geometry of
Interaction&rdquo;, <em>Information and Computation</em>, 111(1):
53&ndash;119.</li>

<li><a name="abramsky99lics"></a>Abramsky, S., and Melli&egrave;s,
Paul-Andr&eacute;, 1999, &ldquo;Concurrent Games and Full Completeness&rdquo;,
<em>14th Annual Symposium on Logic in Computer Science</em>,
Trento: IEEE Computer Society Press., pp. 431&ndash;442.</li>

<li><a name="abrusci91jsl"></a>Abrusci, V. M., 1991, &ldquo;Phase
semantics and sequent calculus for pure non-commutative classical
linear propositional logic&rdquo;, <em>Journal of Symbolic Logic</em>,
56(4): 1403&ndash;1451.</li>

<li><a name="abrusci99apal"></a>Abrusci, V.M., and Ruet, P., 1999,
&ldquo;Non-Commutative Logic I: The Multiplicative
Fragment&rdquo;, <em>Annals of Pure and Applied Logic</em>, 101(1):
29&ndash;64.</li>

<li><a name="allwein93jsl"></a>Allwein, G. and Dunn, J.M., 1993,
&ldquo;Kripke Models for Linear Logic&rdquo;, <em>Journal of Symbolic
Logic</em>, 58(2): 514&ndash;545.</li>

<li><a name="andreoli92jlc"></a>Andreoli, J.-M., 1992, &ldquo;Logic
programming with focusing proofs in linear logic&rdquo;, <em>Journal
of Logic and Computation</em>, 2(3): 297&ndash;347.</li>

<li><a name="andreoli91ngc"></a>Andreoli, J.-M. and Pareschi, R.,
1991, &ldquo;Linear objects: Logical processes with built-in
inheritance&rdquo;, <em>New Generation Computing</em>, 9(3&ndash;4):
445&ndash;473.</li>

<li><a name="asperti98cup"></a>Asperti, A., and Guerrini, S., 1998, 
&ldquo;The Optimal Implementation of Functional
Programming Languages&rdquo;, Cambridge Univ. Press.</li>

<li><a name="avron88tcs"></a>Avron, A., 1988,
&ldquo;The Semantics and Proof Theory of Linear
Logic&rdquo;, <em>Theoretical Computer Science</em>,
57: 161&ndash;184. </li>

<li><a name="baelde12tocl"></a>Baelde, D., 2012, &ldquo;Least and
greatest fixed points in linear logic&rdquo;, ACM Transactions on
Computational Logic, 13(1). doi:10.1145/2071368.2071370</li>

<li><a name="baelde07lpar"></a>Baelde, D. and Miller, D., 2007,
&ldquo;Least and greatest fixed points in linear
logic&rdquo;, <em>Logic for Programming, Artificial Intelligence, and
Reasoning</em> (Lecture Notes in Computer Science: Volume 4790),
edited by N. Dershowitz and A. Voronkov, pp. 92&ndash;106.</li>

<li><a name="baillot15ic"></a>Baillot, P., 2015, &ldquo;On the
expressivity of elementary linear logic: Characterizing Ptime and an
exponential time hierarchy&rdquo;, <em>Information and
Computation</em>, 241: 3&ndash;31.</li>

<li><a name="baillot04lics"></a>Baillot, P., and Terui, K., 2004,
&ldquo;Light Types for Polynomial Time Computation in
Lambda-Calculus&rdquo;, <em>Proceedings of the Nineteenth Annual IEEE
Symposium on Logic in Computer Science</em>, Turku, Finland, IEEE
Computer Society Press, pp. 266&ndash;275.</li>

<li><a name="barr91mscs"></a>Barr, M., 1991, &ldquo;*-Autonomous categories
and linear logic&rdquo;, <em>Mathemathical Structures in Computer
Science</em>, 1(2): 159&ndash;178.</li>

<li><a name="bellantoni92cc"></a>Bellantoni, S. and Cook, S., 1992,
&ldquo;A New Recursion-Theoretic Characterization of the Polytime
Functions&rdquo;,
<em>Computational Complexity</em>, 2: 97&ndash;110.</li>

<li><a name="bimbo15"></a>Bimb&oacute;, K., 2015, &ldquo;The
decidability of the intensional fragment of classical linear
logic&rdquo;, <em>Theoretical Computer Science</em>, 597(13):
1&ndash;17.</li>

<li><a name="blass92apal"></a>Blass, A., 1992, &ldquo;A game semantics
for linear logic&rdquo;, <em>Annals of Pure and Applied Logic</em>,
56: 183&ndash;220.</li>

<li><a name="cervesato99csfw"></a>Cervesato, I., Durgin, N., Lincoln,
P., Mitchell, J., and Scedrov, A., 1999, &ldquo;A meta-notation for protocol
analysis&rdquo;, in R. Gorrieri (ed.), <em>Proceedings of the 12th IEEE
Computer Security Foundations Workshop&mdash;CSFW 1999</em>, Los
Alamitos, CA: IEEE Computer Society Press, pp. 55&ndash;69.</li>

<li><a name="chaudhuri18mscs"></a>Chaudhuri, K., 2018, 
&ldquo;Encoding additives using multiplicatives and subexponentials&rdquo;,
<em>Mathematical Structures in Computer Science</em>, 28(5): 651&ndash;666.</li>

<li><a name="curien03bsl"></a>Curien, P.-L., 2003, &ldquo;Symmetry and
interactivity in programming&rdquo;, <em>Bulletin of Symbolic Logic</em>,
9(2): 169&ndash;180.</li>

<li><a name="danos93kgc"></a>Danos, V., Joinet, J.-P., and Schellinx,
H., 1993, &ldquo;The Structure of Exponentials: Uncovering the
Dynamics of Linear Logic Proofs&rdquo;, pp. 159&ndash;171, in <em>Kurt
G&ouml;del Colloquium</em> (Lecture Notes in Computer Science, Volume
713), edited by G. Gottlob, A. Leitsch, and D. Mundici, Berlin:
Springer.</li>

<li><a name="danos97jsl"></a>&ndash;&ndash;&ndash;, 1997, &ldquo;A New
Deconstructive Logic: Linear Logic&rdquo;, <em>Journal of Symbolic
Logic</em>, 62(3): 755&ndash;807. </li>


<li><a name="danos89aml"></a>Danos, V. and Regnier, L., 1989, 
&ldquo;The Structure of Multiplicatives&rdquo;, 
<em>Archive of Mathematical Logic</em>, Springer,
28:181&ndash;203.</li>

<li><a name="danos95all"></a>&ndash;&ndash;&ndash;, 1995,
&ldquo;Proof-nets and Hilbert space&rdquo;, in J.-Y. Girard,
Y. Lafont, and L. Regnier (eds.), <em>Advances in Linear Logic</em>,
Cambridge: Cambridge University Press, pp. 307&ndash;328.</li>


<li><a name="degroote04lics"></a>de Groote, P., Guillaume, B., and
Salvati, S., 2004, &ldquo;Vector addition tree automata&rdquo;,
in <em>Proceedings of the 19th IEEE Symposium on Logic in Computer
Science</em> (LICS 2004), 14&ndash;17 July 2004, Turku, Finland,
pp. 64&ndash;73.</li>

<li><a name="delande10apal"></a>Delande, O., Miller, D., and Saurin,
A., 2010, &ldquo;Proof and refutation in MALL as a
game&rdquo;, <em>Annals of Pure and Applied Logic</em>, 161(5):
654&ndash;672.</li>

<li><a name="dicosmo97lics"></a>Di Cosmo, R., and Kesner, D., 1997,
&ldquo;Strong normalization of explicit substitutions via cut elimination in
proof nets&rdquo;, (extended abstract) in <em>Proceedings of the Twelfth
Annual IEEE Symposium on Logic in Computer Science</em>, 
Los Alamitos, CA: IEEE Computer Society Press, pp. 35&ndash;46.</li>

<li><a name="ehrhard93mscs"></a>Ehrhard, T., 1993,
&ldquo;Hypercoherences: A Strongly Stable Model of Linear
Logic&rdquo;, <em>Mathematical Structures in Computer Science</em>,
3(4): 365&ndash;385.</li>

<li><a name="fages01ic"></a>Fages, F., Ruet, P., and Soliman, S.,
2001, &ldquo;Linear Concurrent Constraint Programming: Operational and Phase
Semantics&rdquo;, <em>Information and Computation</em>, 165(1): 14&ndash;41.</li>

<li><a name="girard87tcs"></a>Girard, J.-Y., 1987, &ldquo;Linear logic&rdquo;,
<em>Theoretical Computer Science</em>, 50: 1&ndash;102.</li>

<li><a name="girard98ic"></a>&ndash;&ndash;&ndash;, 1998, &ldquo;Light
Linear Logic&rdquo;, <em>Information and Computation</em>,
143(2):175&ndash;204.</li>

<li><a name="grishin81"></a>Grishin, V. N., 1981,
&ldquo;Predicate and set-theoretic calculi based on
logic without contraction rules,&rdquo;
(Russian). Izvestiya Akademii Nauk SSSR Seriya Matematicheskaya
45(1): 47&ndash;68. 239. Math. USSR Izv., 18, no.1, Moscow. </li>

<li><a name="guerrini11tcs"></a>Guerrini, S., 2011, 
&ldquo;A linear algorithm for MLL proof net
correctness and sequentialization&rdquo;, <em>Theoretical
Computer Science</em>, 412: 1958&ndash;1978.</li>

<li><a name="guerrini03tcs"></a>Guerrini, S., Martini, S., and Masini,
A., 2003, &ldquo;Coherence for sharing proof-nets&rdquo;, <em>Theoretical
Computer Science</em>, 294(3): 379&ndash;409.</li>

<li><a name="guglielmi01csl"></a>Guglielmi, A., and Stra&szlig;burger, L.,
2001, &ldquo;Non-commutativity and MELL in the Calculus of Structures&rdquo;,
<em>Computer Science Logic</em> (Lecture Notes in Computer Science,
Volume 2142), Berlin: Springer Verlag, pp. 54&ndash;68.</li>

<li><a name="gunter89atpn"></a>Gunter, C. A., and Gehlot, V., 1989,
&ldquo;Nets as Tensor Theories&rdquo;, in G. De Michelis
(ed.), <em>Proceedings of the Tenth International Conference on
Application and Theory of Petri Nets</em> (Lecture Notes in Computer
Science: Volume 616), Bonn: Springer-Verlag, pp. 174-191.</li>

<li><a name="guzman90lics"></a>Guzman, J.C. and Hudak, P., 1990,
&ldquo;Single-threaded polymorphic lambda calculus&rdquo;,
in <em>Proceedings of the Fifth IEEE Symposium on Logic in Computer
Science</em>, Philadelphia: IEEE Computer Society Press.</li>

<li><a name="heath18jar"></a>Heath, Q. and Miller, D., 2018,
&ldquo;A proof theory for model
checking&rdquo;,
<em>Journal of Automated Deduction</em>, doi:10.1007/s10817-018-9475-3.</li>

<li><a name="heijltjes16lmcs"></a>Heijltjes, W. and Houston, R., 2016,
&ldquo;Proof equivalence in MLL is PSPACE-complete&rdquo;,
<em>Logical Methods in Computer Science</em> 12(1).</li>

<li><a name="heijltjes18tr"></a>Heijltjes, W. B., Hughes, D. J. D.,
and Stra&szlig;burger, L., 2018, &ldquo;Proof nets for first-order additive linear
logic&rdquo;, <em>INRIA Technical Report 9201</em>.</li>

<li><a name="hodas94ic"></a>Hodas, J., and Miller, D., 1994, &ldquo;Logic
programming in a fragment of intuitionistic linear logic&rdquo;,
<em>Information and Computation</em>, 110(2): 327&ndash;365.</li>

<li><a name="hofmann03ic"></a>Hofmann, M., 2003, &ldquo;Linear types and
non-size increasing polynomial time computation&rdquo;, <em>Information and
Computation</em>, 183(1): 57&ndash;85.</li>

<li><a name="howard80"></a>Howard, W.A., 1980, &ldquo;The formulae-as-type
notion of construction, 1969&rdquo;, in J.P. Seldin and R. Hindley (eds.),
<em>To H. B. Curry: Essays in Combinatory Logic, Lambda Calculus, and
Formalism</em>, New York: Academic Press, pp. 479&ndash;490.</li>

<li><a name="hughes05tocl"></a>Hughes, D.J.D. and van Glabbeek, R., 2005,
&ldquo;Proof Nets for Unit-Free Multiplicative-Additive Linear Logic&rdquo;,
<em>ACM Transactions on Computational Logic</em>, 6: 784&ndash;842.</li>

<li><a name="hughes16lics"></a>Hughes, D.J.D. and Heijltjes, W. B.,
2016, &ldquo;Conflict nets: efficient locally canonical mall proof
nets&rdquo;, <em>31st Annual ACM/IEEE Symposium on Logic in Computer
Science</em> (LICS), 2016.</li>

<li><a name="hyland00ic"></a>Hyland, J.M.E., and Ong, C.-H.L.,
2000, &ldquo;On Full Abstraction for PCF: I. Models, observables and the
full abstraction problem, II. Dialogue games and innocent strategies,
III. A fully abstract and universal game model&rdquo;, <em>Information and
Computation</em>, 163: 285&ndash;408.</li>

<li><a name="kanovich92"></a>Kanovich, M.I., 1992, &ldquo;Horn Programming
in Linear Logic is NP-Complete&rdquo;, in <em>Proceedings of the Seventh
Annual Symposium on Logic in Computer Science</em>, Santa Cruz, IEEE
Computer Society Press, pp. 200&ndash;210.</li>

<li><a name="kanovich94trb"></a>&ndash;&ndash;&ndash;, 1994,
&ldquo;Simulating Linear Logic with 1-Linear Logic&rdquo;, Technical
Report 94&ndash;08, Laboratoire de Math&eacute;matiques Discr&egrave;tes,
University of Marseille, 1994.</li>

<li><a name="kobayashi99tcs"></a>Kobayashi, N., Shimizu, T., and
Yonezawa, A., 1999, &ldquo;Distributed concurrent linear logic programming&rdquo;,
<em>Theoretical Computer Science</em>, 227(1&ndash;2): 185&ndash;220.</li>

<li><a name="kopylov95lics"></a>Kopylov, A. P., 1995, 
 &ldquo;Decidability of Linear Affine Logic&rdquo;,
 Symposium on Logic in Computer Science (LICS&rsquo;95), IEEE Computer
 Society Press, pp. 496&ndash;505. </li>

<li><a name="lafont04tcs"></a>Lafont, Y., 2004, &ldquo;Soft linear logic and
polynomial time&rdquo;, <em>Theoretical Computer Science</em>, 318(1&ndash;2):
163&ndash;180.</li>

<li><a name="lambek58amm"></a>Lambek, J., 1958, &ldquo;The mathematics of
sentence structure&rdquo;, <em>American Mathematical Monthly</em>, 65:
154&ndash;169.</li>

<li><a name="lamp90"></a>Lamping, J., 1990, &ldquo;An algorithm for optimal
lambda-calculus reductions&rdquo;. 17th Annual Symposium on Principles of
Programming Languages, San Francisco, ACM Press, pp. 16&ndash;30.</li>

<li><a name="laurent05apal"></a>Laurent, O., Quatrini, M., and Tortora
de Falco, L., 2005, &ldquo;Polarized and focalized linear and
classical proofs&rdquo;, <em>Annals of Pure and Applied Logic</em>,
134 (2&ndash;3): 217&ndash;264.</li>

<li><a name="lazic15tocl"></a>Lazic, R. and Schmitz, S., 2015,
&ldquo;Nonelementary complexities for branching VASS, MELL, and
extensions&rdquo;, <em>ACM Transactions on Computational Logic</em>,
16(3): pp. 20:1&ndash;20:30.</li>

<li><a name="liang09tcs"></a>Liang, C. and Miller, D., 2009,
&ldquo;Focusing and Polarization in Linear, Intuitionistic, and
Classical Logics&rdquo;, <em>Theoretical Computer Science</em>,
410(46): 4747&ndash;4768.</li>

<li><a name="lincoln95all"></a>Lincoln, P., 1995, &ldquo;Deciding
provability of linear logic formulas&rdquo;, <em>Proceedings of the
Workshop on Advances in Linear Logic</em>, J.-Y. Girard, Y. Lafont,
and L. Regnier (eds.), Cambridge: Cambridge University Press,
pp. 197&ndash;210.</li>

<li><a name="lincoln92"></a>Lincoln, P., Mitchell, J., Scedrov, A.,
and Shankar, N., 1992, &ldquo;Decision problems for propositional linear
logic&rdquo;, <em>Annals of Pure and Applied Logic</em>, 56: 239&ndash;311.</li>

<li><a name="lincoln92un"></a>Lincoln, P., and Winkler, T., 1994,
&ldquo;Constant-Only Multiplicative Linear Logic is NP-Complete&rdquo;,
<em>Theoretical Computer Science</em>, 135: 155&ndash;169.</li>

<li><a name="martini95all"></a>Martini, S. and Masini, A., 1995,
&ldquo;On the fine structure of the exponential rule&rdquo;,
in <em>Advances in linear logic</em>, edited by J.-Y. Girard and
Y. Lafont and L. Regnier, pp. 197&ndash;210, New York: Cambridge
University Press.</li>

<li><a name="martinlof82lmps"></a>Martin-L&ouml;f, P., 1982,
&ldquo;Constructive Mathematics and Computer
Programming&rdquo;, <em>Sixth International Congress for Logic,
Methodology, and Philosophy of Science</em>, Amsterdam: North-Holland,
pp. 153&ndash;175.</li>

<li><a name="miller96tcs"></a>Miller, D., 1996, &ldquo;Forum: A
multiple-conclusion specification language&rdquo;, <em>Theoretical Computer
Science</em>, 165(1): 201&ndash;232.</li>

<li><a name="miller03fcs"></a>&ndash;&ndash;&ndash;, 2003, &ldquo;Encryption
as an abstract data-type: An extended abstract&rdquo;, in I. Cervesato
(ed.), <em>16th Workshop on Foundations of Computer Security</em>,
Asilomar, IEEE Computing Society, pp. 3&ndash;14, 2003. </li>

<li><a name="miller04llcs"></a>&ndash;&ndash;&ndash;, 2004,
&ldquo;Overview of linear logic programming&rdquo;, <em>Linear Logic
in Computer Science</em>, T. Ehrhard, J.-Y. Girard, P. Ruet, and
P. Scott (eds.) (London Mathematical Society Lecture Notes: Volume
316), Cambridge: Cambridge University Press, pp. 119&ndash;150.</li>

<li><a name="murawski06tocl"></a>Murawski, A. S., and Ong, C.-H. L., 2006, 
&ldquo;Fast verification of MLL proof nets via
IMLL&rdquo;, <em>ACM Transactions on Computational Logic</em>, 
7(3): 473&ndash;498.</li>

<li><a name="nigam09ppdp"></a>Nigam, V. and Miller, D., 2009,
&ldquo;Algorithmic specifications in linear logic with
subexponentials&rdquo;, Proceedings of the 11th ACM SIGPLAN conference
on Principles and practice of declarative programming (PPDP), 2009,
pp. 129&ndash;140.</li>

<li><a name="read88"></a>Read, S., 1988, <em>Relevant Logic</em>,
Oxford: Blackwell. </li>

<li><a name="retore97tlca"></a>Retor&eacute;, C., 1997, &ldquo;Pomset
logic: a non-commutative extension of classical linear
logic&rdquo;, <em>Typed Lambda Calculi and Applications</em> (Lecture
notes in Computer Science: Volume 1210), Berlin: Springer Verlag,
pp. 300&ndash;318.</li>

<li><a name="retore03tcs"></a>Retor&eacute;, C., 2003,
&ldquo;Handsome proof-nets: perfect matchings and cographs&rdquo;,
<em>Theor. Comput. Sci.</em>, 294(3): 473&ndash;488.
</li>

<li><a name="reutenauer89"></a>Reutenauer, C., 1989, &ldquo;Aspects
math&eacute;matiques des r&eacute;seaux de Petri&rdquo;, Etudes et
Recherches en Informatique. Masson.
</li>

<li><a name="strassburger18tr"></a>Stra&szlig;burger, L., forthcoming,
&ldquo;On the Decision Problem for MELL&rdquo;, <em>Theoretical
Computer Science</em>, first online 28 February
2019. doi:10.1016/j.tcs.2019.02.022</li>

<li><a name="urquhart00lc"></a>Urquhart, A., 2000, &ldquo;The
Complexity of Linear Logic with Weakening&rdquo;, <em>Logic Colloquium
&rsquo;98</em> (Lecture Notes in Logic 13), Urbana: Association for
Symbolic Logic, pp. 500&ndash;515.
</li>

<li><a name="wadler91pepm"></a>Wadler, P., 1991, &ldquo;Is there a use for
linear logic?&rdquo;, <em>Proceedings of ACM/SIGPLAN Workshop Partial
Evaluation and Semantics-Based Program Manipulation</em>, New Haven:
ACM Press, pp. 255&ndash;273, 1991.</li>

<li><a name="yetter90jsl"></a>Yetter, D.N., 1990, &ldquo;Quantales and
(noncommutative) linear logic&rdquo;, <em>Journal of Symbolic Logic</em>,
55(1): 41&ndash;64.</li>

</ul>

</div>

<div id="academic-tools">

<h2 id="Aca">Academic Tools</h2>

<blockquote>
<table class="vert-top">
<tr>
<td><img src="../../symbols/sepman-icon.jpg" alt="sep man icon" /></td>
<td><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=logic-linear" target="other">How to cite this entry</a>.</td>
</tr>

<tr>
<td><img src="../../symbols/sepman-icon.jpg" alt="sep man icon" /></td>
<td><a href="https://leibniz.stanford.edu/friends/preview/logic-linear/" target="other">Preview the PDF version of this entry</a> at the
 <a href="https://leibniz.stanford.edu/friends/" target="other">Friends of the SEP Society</a>.</td>
</tr>

<tr>
<td><img src="../../symbols/inpho.png" alt="inpho icon" /></td>
<td><a href="https://www.inphoproject.org/entity?sep=logic-linear&amp;redirect=True" target="other">Look up topics and thinkers related to this entry</a>
 at the Internet Philosophy Ontology Project (InPhO).</td>
</tr>

<tr>
<td><img src="../../symbols/pp.gif" alt="phil papers icon" /></td>
<td><a href="http://philpapers.org/sep/logic-linear/" target="other">Enhanced bibliography for this entry</a>
at <a href="http://philpapers.org/" target="other">PhilPapers</a>, with links to its database.</td>
</tr>

</table>
</blockquote>

</div>

<div id="other-internet-resources">

<h2><a name="Oth">Other Internet Resources</a></h2>

<ul>

<li>The
 <a href="http://www.cs.cmu.edu/~carsten/linearbib/llb.html" target="other">linear logic bibliography</a>
 (up to 1998).</li>

<li>Vincent Danos and Roberto Di Cosmo. 
<a href="http://www.dicosmo.org/CourseNotes/LinLog/" target="other">The Linear Logic Primer. Course Notes.</a> 
(1992).</li>

</ul>

</div>

<div id="related-entries">

<h2><a name="Rel">Related Entries</a></h2>

<p>

 <a href="../logic-games/index.html">logic: and games</a> |
 <a href="../logic-classical/index.html">logic: classical</a> |
 <a href="../logic-dialogical/index.html">logic: dialogical</a> |
 <a href="../logic-intuitionistic/index.html">logic: intuitionistic</a> |
 <a href="../logic-substructural/index.html">logic: substructural</a> |
 <a href="../proof-theory/index.html">proof theory</a>

</p>

</div>

<div id="acknowlegment">
<h3><a name="Ack">Acknowlegment</a></h3>

<p>
We thank an anonymous reviewer at the SEP for many comments that have
helped us revise this article.</p>

</div>

<script type="text/javascript" src="local.js"></script>
<script type="text/javascript" src="../../MathJax/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>


</div><!-- #aueditable --><!--DO NOT MODIFY THIS LINE AND BELOW-->

<!-- END ARTICLE HTML -->

</div> <!-- End article-content -->

  <div id="article-copyright">
    <p>
 <a href="../../info.html#c">Copyright &copy; 2019</a> by

<br />
<a href="http://www.dicosmo.org/" target="other">Roberto Di Cosmo</a>
&lt;<a href="m&#97;ilto:roberto&#37;40dicosmo&#37;2eorg"><em>roberto<abbr title=" at ">&#64;</abbr>dicosmo<abbr title=" dot ">&#46;</abbr>org</em></a>&gt;<br />
<a href="http://www.lix.polytechnique.fr/Labo/Dale.Miller/" target="other">Dale Miller</a>
&lt;<a href="m&#97;ilto:dale&#37;2emiller&#37;40inria&#37;2efr"><em>dale<abbr title=" dot ">&#46;</abbr>miller<abbr title=" at ">&#64;</abbr>inria<abbr title=" dot ">&#46;</abbr>fr</em></a>&gt;
    </p>
  </div>

</div> <!-- End article -->

<!-- NOTE: article banner is outside of the id="article" div. -->
<div id="article-banner" class="scroll-block">
  <div id="article-banner-content">
    <a href="../../fundraising/index.html">
    Open access to the SEP is made possible by a world-wide funding initiative.<br />
    The Encyclopedia Now Needs Your Support<br />
    Please Read How You Can Help Keep the Encyclopedia Free</a>
  </div>
</div> <!-- End article-banner -->

    </div> <!-- End content -->

    <div id="footer">

      <div id="footer-menu">
        <div class="menu-block">
          <h4><i class="icon-book"></i> Browse</h4>
          <ul role="menu">
            <li><a href="../../contents.html">Table of Contents</a></li>
            <li><a href="../../new.html">What's New</a></li>
            <li><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/random">Random Entry</a></li>
            <li><a href="../../published.html">Chronological</a></li>
            <li><a href="../../archives/index.html">Archives</a></li>
          </ul>
        </div>
        <div class="menu-block">
          <h4><i class="icon-info-sign"></i> About</h4>
          <ul role="menu">
            <li><a href="../../info.html">Editorial Information</a></li>
            <li><a href="../../about.html">About the SEP</a></li>
            <li><a href="../../board.html">Editorial Board</a></li>
            <li><a href="../../cite.html">How to Cite the SEP</a></li>
            <li><a href="../../special-characters.html">Special Characters</a></li>
            <li><a href="../../tools/index.html">Advanced Tools</a></li>
            <li><a href="../../contact.html">Contact</a></li>
          </ul>
        </div>
        <div class="menu-block">
          <h4><i class="icon-leaf"></i> Support SEP</h4>
          <ul role="menu">
            <li><a href="../../support/index.html">Support the SEP</a></li>
            <li><a href="../../support/friends.html">PDFs for SEP Friends</a></li>
            <li><a href="../../support/donate.html">Make a Donation</a></li>
            <li><a href="../../support/sepia.html">SEPIA for Libraries</a></li>
          </ul>
        </div>
      </div> <!-- End footer menu -->

      <div id="mirrors">
        <div id="mirror-info">
          <h4><i class="icon-globe"></i> Mirror Sites</h4>
          <p>View this site from another server:</p>
        </div>
        <div class="btn-group open">
          <a class="btn dropdown-toggle" data-toggle="dropdown" href="https://plato.stanford.edu/">
            <span class="flag flag-usa"></span> USA (Main Site) <span class="caret"></span>
            <span class="mirror-source">Philosophy, Stanford University</span>
          </a>
          <ul class="dropdown-menu">
            <li><a href="../../mirrors.html">Info about mirror sites</a></li>
          </ul>
        </div>
      </div> <!-- End mirrors -->
      
      <div id="site-credits">
        <p>The Stanford Encyclopedia of Philosophy is <a href="../../info.html#c">copyright &copy; 2021</a> by <a href="http://mally.stanford.edu/">The Metaphysics Research Lab</a>, Department of Philosophy, Stanford University</p>
        <p>Library of Congress Catalog Data: ISSN 1095-5054</p>
      </div> <!-- End site credits -->

    </div> <!-- End footer -->

  </div> <!-- End container -->

   <!-- NOTE: Script required for drop-down button to work (mirrors). -->
  <script>
    $('.dropdown-toggle').dropdown();
  </script>

</body>

<!-- Mirrored from seop.illc.uva.nl/entries/logic-linear/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 22 Jun 2022 19:51:23 GMT -->
</html>
